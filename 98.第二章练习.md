# 第一章  构造数据抽象

## 2.1 数据抽象导引

### 练习2.1

> 请定义出make-rat的一个更好的版本，使之可以处理正数和负数。当有理数为正时，make-rat应当将其规范化，使他的分子和分母都是正的。如果有理数为负，那么就应只让分子为负。

```lisp
(define (make-rat n d)
        (let ((g (gcd (abs n) (abs d))))
             (cond ((> d 0) (cons (/ n g) (/ d g)))
                   ((< d 0) (cons (- (/ n g)) (- (/ d g))))
                   (else (error "error" d)))))
```

* 对于有理数(make-rat n d),当(d>0)时，有理数符号与n相同，(d<0)时，有理数符号与n相反。
* `(gcd (abs n) (abs d))`保证n，d的最大公约数为正。

### 练习2.2

> 请考虑平面上线段的表示问题。一个线段用一对点表示，它们分别是线段的始点与终点。请定义构造函数make-segment和选择函数start-segment、end-segment，它们给予点定义线段的表示。进而，一个点可以用数的序对表示，序对的两个成分分别表示点的x坐标和y坐标。请据此进一步给出构造函数make-point和选择函数x-point、y-point，用它们定义出点的这种表示。最后，请基于所定义的构造函数和选择函数，定义出过程midpoint-segment，他以一个线段为参数，返回线段的中点(也就是那个坐标值是两个端点的平均值的点)。为了实验这些过程，还需要定义一种打印点的方法：

```lisp
(define (print-point p)
        (newline)
        (display "(")
        (display (x-point p))
        (display ",")
        (display (y-point p))
        (display ")"))
```

### 练习2.3

> 请实现一种平面矩形的表示(提示：你有可能借用练习2.2的结果)。基于你的构造函数和选择函数定义几个过程，计算给定矩形的周长和面积等。现在请再为矩形实现另一种表示方式。你应该怎样设计系统，使之能够提供适当的抽象屏障，使同一个周长或者面积过程对两种不同表示都能工作。

要确定平面上矩形的位置和形状，可以给出矩形的4个点或四条边，。每条边都可以用矩形的两个相邻的顶点表示。
假设矩型的四个点分别是ABCD，实际上给出三个点ABC就可以确定第四个点的位置，给出任意两条边也可以确定矩形的位置。
矩形的周长和面积依赖于矩形的长和宽，定义(r-length rect)和(r-width rect)，将矩形的实现与矩形的周长和面积的计算过程隔离开，当矩形的实现修改时，只需要修改(r-length rect)和(r-width rect)的实现。
矩形的构造函数可以使用点(rectangle point-A point-B point-C point-D)；可以使用边(互相平行的两条边)(rectangle segment-AB segment-CD)最后都返回两条边的序对(cons AB CD)
矩形的选择函数可以给出(point-A rect)(point-B rect)(point-C rect)(point-D rect)和边(segment-AB rect)(segment-BC rect)(segment-CD rect)(segment-DA rect)

```lisp
(define (perimeter rect)
        (* 2 (+ (r-length rect) (r-width rect))))

(define (area rect)
        (* (r-length rect) (r-width rect)))
```

### 练习2.4

> 下面是序对的另一种过程性表示方式。请针对这一验证，对于任意的x和y，`(car (cons x y))`都将产生出x。
> ```lisp
> (define (cons x y)
>         (lambda (m) (m x y)))
>
> (define (car z)
>         (z (lambda (p q) p)))
> ```
> 对应的cdr应该如何定义？(提示：为了验证这一表示确实能行，请利用1.1.5节的代换模型。)

```lisp
(car (cons x y))
(car (lambda (m) (m x y)))
((lambda (m) (m x y)) (lambda (p q) p))
((lambda (p q) p) x y)
x
```

```lisp
(define (cdr z)
        (z (lambda (p q) q)))
```

### 练习2.5

> 请证明，如果将a和b的序对表示为乘积$2^a3^b$对应的整数，我们就可以只用非负整数和算术运算表示序对。亲给出对应的过程cons、car和cdr的定义。

对于任意(a,b)都有唯一的$2^a3^b$与之对应。
可以从$2^a3^b$还原出(a,b)
$f(a,b)=2^a3^b$
假设$f(a_1,b_1)f(a_2,b_2) (a_1\not=a_2,b_1\not=b_2)$对应相同的值
$
\begin{aligned}
&2^{a_1}3^{b_1}-2^{a_2}3^{b_2}=0 \\
&2^{a_1}3^{b_1}(1-2^{a_2-a_1}3^{b_2-b_1})=0 \\
&2^{a_2-a_1}3^{b_2-b_1}=1 \\
& \\
&a_1\not=a_2,b_1\not=b_2 \\
&2^{a_2-a_1}3^{b_2-b_1}\not=1
\end{aligned}
$
假设不成立。
$
\begin{aligned}
&f(a,b)=2^a3^b \\
&a=\log_2 {\frac {f(a,b)} {3^b}} \\
&b=\log_3 {\frac {f(a,b)} {2^a}}
\end{aligned}
$

```lisp
(define (cons a b)
        (* (expt 2 a) (expt 3 b)))

(define (car n)
        (define (mod3 x)
                (if (= (mod x 3) 0)
                    (mod3 (/ x 3))
                    x))
        (log (mod3 n) 2))

(define (cdr n)
        (define (mod2 x)
                (if (= (mod x 2) 0)
                    (mod2 (/ x 2))
                    x))
        (log (mod2 n) 3))
```

### 练习2.6

> 如果觉得将序对表示为过程还不足以令人如雷灌顶，那么请考虑，在一个可以对过程做各种操作的语言里，我们完全可以没有数(至少在只考虑非负整数的情况下)，可以将0和加1操作实现为：
> ```lisp
> (define zero (lambda (f) (lambda (x) x)))
> 
> (define (add-1 n)
>         (lambda (f) (lambda (x) (f ((n f) x)))))
> ```
> 这一表示形式称为Church计数，名字来源于其发明人数理逻辑学家Alonzo Church(丘奇),$\lambda$演算也是他发明的。
请直接定义one和two(不用zero和add-1)(提示：利用代换去求值(add-1 zero))。请给出加法过程+的一个直接定义(不要通过反复应用add-1)。

```lisp
(add-1 zero)
(add-1 (lambda (f) (lambda (x) x)))
(lambda (g) (lambda (y) (g ((n g) y))))
(lambda (g) (lambda (y) (g (((lambda (f) (lambda (x) x)) g) y))))
(lambda (g) (lambda (y) (g (y))))
(lambda (f) (lambda (x) (f x)))

(define one (lambda (f) (lambda (x) (f x))))
(define two (lambda (f) (lambda (x) (f f(x)))))

(define (add a b)
        (lambda (f)
                (lambda (x)
                        (b (f (a f) x)))))
```

zero没有参数，返回一个过程，这个过程接受一个参数f，返回一个对这个参数什么也不做的过程。
add-1接受一个参数n,返回一个过程，该过程也接受一个参数f，返回另一个过程，该过程接受一个参数x，并进行如下操作：1.将n应用于f得到一个过程，2.将得到的这个过程应用于x，3，将f应用于2得到的结果。

当定义了0和+1两个过程后，就可以由这两个过程描述出1和1之后的所有数。add-1过程中的关键步骤(n f)，n可以表述为(add-1 (add-1 (add-1 ...(add-1 zero))))的一个递归过程。

### 练习2.7

> Alyssa的程序是不完整的，因为她还没有确定区间抽象的实现。这里是区间构造符的定义：
> `(define (make-interval a b) (cons a b))`
> 请定义选择符upper-bound和lower-bound，完成这一实现。

```lisp
(define (upper-bound n)
        (max (car n) (cdr n)))

(define (lower-bound n)
        (min (car n) (cdr n)))
```

### 练习2.8

> 通过类似于Alyssa的推理，说明两个区间的差应该怎样计算。请定义出相应的减法过程sub-interval。

```lisp
(define (sub-interval a b)
        (make-interval (- (lower-bound a) (upper-bound b))
                       (- (upper-bound a) (lower-bound b))))
```

### 练习2.9

> 区间的宽度就是其上界和下界之差的一半。区间宽度是有关区间所描述的相应数值的非确定性的一种度量。对于某些算术运算，两个区间的组合结果的宽度就是参数区间参数的函数，而对其他运算，组合区间的宽度则不是区间宽度的函数。证明两个区间的和(与差)的宽度就是被加(或减)的区间的宽度的函数。举例说明，对于乘和除而言，情况并非如此。

$
\begin{aligned}
&a=(a_1,a_2) \\
&b=(b_1,b_2) \\
&a_length=(a_2-a_1)/2 \\
&b_length=(b_2-b_1)/2 \\
&m=a+b=(a_1+b_1,a_2+b_2) \\
&n=a-b=(a_1-b_2,a_2-b_1) \\
&m_length=(a_2+b_2-(a_1+b_1))/2=a_length+b_length \\
&n_length=(a_2-b_1-(a_1-b_2))/2=a_length+b_length \\
&a=(1,3) \to length=1\\
&b=(2,10) \to length=4\\
&ab=(2 30) \to length=14 \\
&a=(2,4) \to length=1 \\
&b=(3 11) \to length=4 \\
&ab=(6,44) \to length=19
\end{aligned}
$

### 练习2.10

> BenBitdiddle是个专业程序员，他看了Alyssa工作后评论说，除以一个跨过横跨0的区间的意义不清楚。请修改Alyssa的代码，检查这种情况并在出现这一种情况时报错。

```lisp
(define (div-interval x y)
        (if (<= (* (upper-bound y) (lower-bound y)) 0)
            (error "y" y)
            (mul-interval x
                           (make-interval (/ 1.0 (upper-bound y))
                                          (/ 1.0 (lower-bound y))))))
```

### 练习2.11

> 在看了这些东西之后，Ben又说出了下面这段有些神秘的话:"通过监测区间的端点，有可能将mul-interval分解为9种情况，每种情况中所需的乘法都不超过两次"。请根据Ben的建议重写这个过程。

$
\begin{aligned}
&a=(a_l,a_u) \\
&b=(b_l,b_u) \\
&(1)a_l \geqslant 0,b_l \geqslant 0\\
&(2)a_l \geqslant 0,b_l \lt 0,b_u \geqslant 0 \\
&(3)a_l \geqslant 0,b_l \lt 0,b_u \lt 0  \to a_l \geqslant 0,b_u \lt 0\\
&(4)a_l \lt 0,a_u \geqslant 0,b_l \geqslant 0 \\
&(5)a_l \lt 0,a_u \lt 0,b_l \geqslant 0 \to a_u \lt 0,b_l \geqslant 0 \\
&(6)a_l \lt 0,a_u \geqslant 0,b_l \lt 0,b_u \geqslant 0 \\
&(7)a_l \lt 0,a_u \geqslant 0,b_l \lt 0,b_u \lt 0 \to a_l \lt 0,a_u \geqslant 0,b_u \lt 0\\
&(8)a_l \lt 0,a_u \lt 0,b_l \lt 0,b_u \geqslant 0 \to a_u \lt 0,b_l \lt 0,b_u \geqslant 0\\
&(9)a_l \lt 0,a_u \lt 0,b_l \lt 0,b_u \lt 0 \to a_u \lt 0,b_u \lt 0\\
\end{aligned}
$

### 练习2.12

> 请定义一个构造函数make-center-percent，他以一个中心点和一个百分比为参数，产生出所需要的区间。你还需要定义选择函数percent，通过它可以得到给定区间的百分数误差，选择函数center与前面定义的一样。

> 区间的宽度就是其上界和下界之差的一半。(练习2.9)

```lisp
(define (make-center-percent c p)
        (make-interval (+ c (* c p))
                       (- c (* c p))))

(define (percent i)
        (/ (- (upper-bound i) (lower-bound i))
           2
           (center i)))
```

### 练习2.13

> 请证明，在误差为很小的百分数的条件下，存在着一个简单公式，利用它可以从两个被乘区间的误差算出乘积的百分数误差值。你可以假定所有的数为正，以简化这一问题。

$
\begin{aligned}
ab&=(a_{l}b_{l},a_{u}b_{u}) \\
&=(a(1-p_{a})b(1-p_{b}),a(1+p_{a})b(1+p_{b})) \\
&=(ab(1-p_{a}-p_{b}+p_{a}p_{b}),ab(1+p_{a}p_{b}+p_{a}+p_{b})) \\
&=(ab(1+p_{a}p_{b}-(p_{a}+p_{b})),ab(1+p_{a}p_{b}+(p_{a}+p_{b})))) \\
w_{ab}&=(ab(1+p_{a}p_{b}+(p_{a}+p_{b}))-ab(1+p_{a}p_{b}-(p_{a}+p_{b})))/2 \\
&=ab(2(p_{a}+p_{b}))/2 \\
&=ab(p_{a}+p_{b}) \\
c_{ab}&=(ab(1+p_{a}p_{b}+(p_{a}+p_{b}))+ab(1+p_{a}p_{b}-(p_{a}+p_{b})))/2 \\
&=ab(2+2p_ap_b)/2 \\
&=ab(1+p_ap_b) \\
p_{ab}&=w_{ab}/c_{ab} \\
&=ab(p_a+p_b)/ab(1+p_ap_b) \\
&=\frac {p_a+p_b} {1+p_ap_b}
\end{aligned}
$

### 练习2.14

> 请确认Lem是对的。请你用各种不同的算术表达式来检查这一系统的行为。请做出两个区间A和B，并用他们计算表达式A/A和A/B。如果所用区间的宽度对于中心值取很小百分数，你将会得到更多的认识。请检查对于中心-百分比形式(见练习2.12)进行计算的结果。

$A/A\not= (1,1)$

### 练习2.15

> 另一用户Eva Lu Ator也注意到了由不同的等价代数表达式计算出的区间的差异。她说，如果一个公式可以写成一种形式，其中具有非准确性的变量不重复出现，那么Alyssa的系统产生出的区间的限界更紧一些。她说，在计算并联电阻时，par2是比par1"更好的"程序。她说的对吗？

par2能得到正确的结果。但Eva的解释不对。当R1,R2都去最小值时，并联电阻值为最小值，当R1，R2都取最大值时，并联电阻取最大值，即$R(r1,r2)=(\frac{R1_lR2_l} {R1_l+R2_l},\frac{R1_uR2_u} {R1_u+R2_u})$

### 练习2.16

> 请给出一个一般性的解释：为什么等价的代数表达式可能导致不同计算结果？你能设计出一个区间算术包，使之没有这种缺陷吗？或者这个事情根本不可能做到？(警告：这个问题非常难。)

Alyssa给出的实现中(div-interval)和(mul-interval)不是逆运算。
对于实际运算(-2,3)*(4,5)=(-10,15)=(-2,3)*(3,5)也不是逆运算，因此区间运算不满足数的运算的规律，因此数的运算中等价的代数表达式对于区间运算而言不一定等价。在练习2.11中，可以看到，做区间乘法时，不一定会用到区间的四个边界。

### 练习2.17

> 请定义出过程last-pair,它返回只包含给定(非空)表里最后一个元素表：
> ```lisp
> (last-pair (list 23 72 149 34))
> (34)
> ```

```lisp
(define (last-pair items)
        (let ((p (- (length items) 1)))
             (list (list-ref items p))))
```

### 练习2.18

> 请定义出过程reverse,它以一个表为参数，返回的表中所包含的元素与参数表相同，但排列顺序与参数表相反：
> ```lisp
> (reverse (list 1 4 9 16 25))
> (25 16 9 4 1)
> ```

```lisp
(define (reverse items)
        (define (iter r next)
                (if (null? next)
                    r
                    (iter (cons (car next) r) (cdr next))))
        (iter (list) items))
```

### 练习2.19

> 请考虑1.2.2节的兑换零钱计数程序。如果能轻而易举地改变程序里所用的兑换币种就更好了。譬如说，那样我们就能计算出1英镑的不同兑换方式的数目。在写前面那个程序时，有关币种的知识中有一部分出现在过程first-denomination里，另一部分出现在过程count-change(它知道有5种U.S.硬币)。如果能够用一个表来提供可用于兑换的硬币就好了。
我们希望重写出过程cc，使其第二个参数是一个可用硬币的币值表，而不是一个制定可用硬币种类的整数。而后我们就可以针对各种货币定义出一些表：
> ```lisp
> (define us-coins (list 50 25 10 5 1))
> (define uk-coins (list 100 50 20 10 5 2 1 0.5))
> ```
> 然后我们就可以通过如下方式调用cc：
> ```lisp
> (cc 100 us-coins)
> 292
>```
> 为了做到这件事，我们需要对程序cc做一些修改。他仍然具有同样的形式，但将以不同的方式访问自己的第二个参数，如下面所示：
> ```lisp
> (define (cc amount coin-values)
>         (cond ((= amount 0) 1)
>               ((or (< amount 0) (no-more? coin-values)) 0)
>               (else
>                (+ (cc amount 
>                       (except-first-denomination coin-values))
>                   (cc (- amount (first-denomination coin-values))
>                       coin-values)))))
> ```
> 请基于表结构上的基本操作，定义出过程first-denomination、except-first-denomination和no-more?。表coin-values的排列顺序会影响cc给出的回答吗？为什么?

```lisp
(define (first-denomination coin-values)
        (car coin-values))

(define (except-first-denomination coin-values)
        (cdr coin-values))

(define (no-more? coin-values)
        (null? coin-values))
```
coin-values的顺序不影响结果。

### 练习2.20

> 过程+、*和list可以取任意个数的实际参数。定义这类过程的一种方式是用一种带点尾部记法形式的define。在一个过程定义中，如果在形式参数表的最后一个参数之前有一个点号，那就表明，当这一过程被实际调用时，前面各个形式参数(如果有的话)将以前面的各个实际参数为值，与平常一样。但最后一个形式参数将以所有剩下的实际参数的表为值。例如，假若我们定义了：
> `(define (f x y . z) <body>)`
> 过程f就可以用两个以上的参数调用。如果求值：
> `(f 1 2 3 4 5 6)`
> 那么在f的体里，x将是1，y将是2，而z将是表(3 4 5 6)。给了定义：
> `(define (g . w) <body>)`
> 过程g可以用0个或者多个参数调用。如果求值：
> `(g 1 2 3 4 5 6)`
> 那么在g的体里，w将是表(1 2 3 4 5 6)。
请采用这一记法形式写出过程same-parity，他以一个或者多个整数为参数，返回所有与其第一个参数有着同样奇偶性的参数形成的表。例如；
> ```lisp
> (same-parity 1 2 3 4 5 6 7)
> (1 3 5 7)
> (same-parity 2 3 4 5 6 7)
> (2 4 6)
> ```

```lisp
(define (same-parity x . y)
        (define (same a b)
                (if (even? a)
                    (if (even? b)
                        (list b)
                        (list))
                    (if (even? b)
                        (list)
                        (list b))))
        (define (iter r next)
                (if (null? next)
                    r
                    (iter (append r (same x (car next))) (cdr next))))
        (iter (list x) y))
```

### 练习2.21

> 过程square-list以一个数值表为参数，返回每个数的平方构成的表：
> ```lisp
> (square-list (list 1 2 3 4))
> (1 4 9 16)
> ```
> 下面是square-list的两个定义，请填充其中缺少的表达式以完成它们：
> ```lisp
> (define (square-list items)
>         (if (null? items)
>             nil
>             (cons <??> <??>)))
> (define (square-list items)
>         (map <??> <??>))
> ```

```lisp
(define (square-list items)
         (if (null? items)
             nil
             (cons (square (car items)) (square-list (cdr items)))))

(define (square-list-map items)
        (map square items))
```

### 练习2.22

> Louis Reasoner试图重写练习2.21的第一个square-list过程，希望使它能生成一个迭代计算过程：
> ```lisp
> (define (square-list items)
>         (define (iter things answer)
>                 (if (null? things)
>                     answer
>                     (iter (cdr things)
>                           (cons (square (car things))
>                                 answer))))
>         (iter items nil))
> ```
> 但是很不幸，在按这种方式定义出的square-list产生出的结果表中，元素的顺序正好与我们需要的相反。为什么？
Loius又试着修正其程序，交换了cons的参数：
> ```lisp
> (define (square-list items)
>         (define (iter things answer)
>                 (if (null? things)
>                     answer
>                     (iter (cdr things)
>                           (cons answer
>                                 (square (car things))))))
>         (iter items nil))
> ```
> 但还是不行。请解释为什么。

```lisp
(iter (1 2 3 4) nil)
(iter (2 3 4) (cons 1 nil))
(iter (2 3 4) (1))
(iter (3 4) (cons 4 (1)))
(iter (3 4) (4 1))
...
(16 9 4 1)

(iter (1 2 3 4) nil)
(iter (2 3 4) (cons nil 1))
(iter (2 3 4) (1))
(iter (3 4) (cons (1) 4))
(iter (3 4) ((1) 4))
...
((((1) 4) 9) 16)
```

### 练习2.23

> 过程for-each与map类似，它以一个过程和一个元素表为参数，但它并不返回结果的表，只是将这一过程从左到右应用于各个元素，将过程应用于元素得到的值都丢掉不用。for-each通常用于那些执行了某些动作的过程，如打印等。看下面例子：
> ```lisp
> (for-each (lambda (x) 
>                   (newline)
>                   (display x))
>           (list 57 321 88))
> ```
> for-each的调用返回的值(上面没有显示)可以是某种任意的东西，例如逻辑值真。请给出一个for-each的实现。

```lisp
(define (for-each f items)
        (define (f-run n)
                (f n)
                f)
        (define (iter r next)
                (if (null? next)
                    f
                    (iter (f-run (car next)) (cdr next))))
        (iter f-run items))
```

### 练习2.24

> 假定现在要求值表达式(list 1 (list 2 (list 3 4)))，请给出由解释器打印出的结果，给出与之对应的盒子指针结构，并将它解释为一棵树。(参见图2-6)。

`(1 (2 (3 4)))`

### 练习2.25

> 给出能够从下面各表中取出7的car和cdr组合：
> ```lisp
> (1 3 (5 7) 9)
> ((7))
> (1 (2 (3 (4 (5 (6 7)))))
> ```

```lisp
(car (cdr (car (cdr (cdr a)))))
(car (car b))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr c))))))))))))
```

```lisp
(cdr list) 返回一个序对
(cdr (list 1 2))
=>(2)<=>(list 2)
(cdr (list 1 (list 2)))
=>((2))<=>(list (list 2))
```

### 练习2.26

> 假定已将x和y定义为如下的两个表：
`(define x (list 1 2 3))`
`(define y (list 4 5 6))`
解释器对于下面各个表达式将打印出什么结果：
`(append x y)`
`(cons x y)`
`(list x y)`

```lisp
(append x y)
=>(1 2 3 4 5 6)
(cons x y)
=>((1 2 3) 4 5 6)
(list x y)
((1 2 3) (4 5 6))
```

(append x y):表x和表y的元素组合成一个新表(将表y的元素顺序添加到表x之后)
(append (list 1 2) (list 3 (list 4 5)))
=>(1 2 3 (4 5))
(cons x y):在表y之前增加一个元素(表x)
(list x y):将表x和表y组合成新的表(x y)(表x，y作为新表的元素)

### 练习2.27

> 修改练习2.18中所做的reverse过程，得到一个deep-reverse过程。他以一个表为参数，返回另一个表作为值，结果表中的元素反转过来，其中的子树也反转。例如：
> ```lisp
> (define x (list (list 1 2) (list 3 4)))
> x
> ((1 2) (3 4))
> (reverse x)
> ((3 4) (1 2))
> (deep-reverse x)
> ((4 3) (2 1))
> ```

```lisp
(define (deep-reverse items)
        (define (iter r next)
                (if (pair? next)
                    (append (iter r (cdr next)) (list (iter r (car next))))
                    next))
        (iter (list) items))
```

### 练习2.28

> 写一个过程fringe，他以一个树(表示为表)为参数，返回一个表，表中的元素是这棵树的所有树叶，按照从左到右的顺序。例如：
> ```lisp
> (define x (list (list 1 2) (list 3 4)))
> (fringe x)
> (1 2 3 4)
> (fringe (list x x))
> (1 2 3 4 1 2 3 4)
> ```

```lisp
(define (fringe items)
        (define (append-not-pair i)
                (if (null? i)
                    i
                    (list i)))
        (define (iter r next)
                (if (pair? next)
                    (append (iter r (car next)) (iter r (cdr next)))
                    (append-not-pair next)))
        (iter (list) items))
```

### 练习2.29

> 一个二叉活动体由两个分支组成，一个是左分支，另一个是右分支。每个分支是一个具有确定长度的杆，上面或者吊着一个重量，获证吊着另一个二叉活动体。我们可以用复合数据对象表示这种二叉活动体，将它通过其两个分支构造起来(例如，使用list):
> ```lisp
> (define (make-mobile left right)
>         (list left right))
> ```
> 分支可以从一个length(他应该是一个数)再加上一个structure构造出来，这个structure或者是一个数(表示一个简单重量)，或者是另一个活动体：
> ```lisp
> (define (make-branch length structure)
>         (list length structure))
> ```
> a)请写出相应的选择函数left-branch和right-branch，它们分别返回活动体的两个分支。还有branch-length和branch-structure，它们返回一个分支上的成分。
b)用你的选择函数定义过程total-weight，它返回一个活动体的总重量。
c)一个活动体称为是平衡的，如果其左分支的力矩等于其右分支的力矩(也就是说，如果其左杆长度乘以吊在杠上的重量，等于这个活动体右边的同样乘积)，而且在其每个分支上吊着的子活动体也都平衡。请设计一个过程，他能检查一个二叉活动体是否平衡。
d)假定我们改变活动体的表示，采用下面的构造方式：
> ```lisp
> (define (make-mobile left right)
>         (cons left right))
> (define (make-branch length structure)
>         (cons length structure))
> ```
> 你需要对自己的程序做多少修改，才能将它改为使用这种新表示？

```lisp
(define (total-weight mobile)
        (define (have-mobile? branch)
                (if (pair? branch)
                    (pair? (branch-structure branch))
                    #f))
        (define (branch-weight branch)
                (if (have-mobile? branch)
                    (total-weight (branch-structure branch))
                    (branch-structure branch)))
        (+ (branch-weight (left-branch mobile))
           (branch-weight (right-branch mobile))))

(define (balance? mobile)
        (define (have-mobile? branch)
                (if (pair? branch)
                    (pair? (branch-structure branch))
                    #f))
        (define (branch-weight branch)
                (if (have-mobile? branch)
                    (total-weight (branch-structure branch))
                    (branch-structure branch)))
        (define (left-moment m)
                (* (branch-length (left-branch m))
                   (branch-weight (left-branch m))))
        (define (right-moment m)
                (* (branch-length (right-branch m))
                   (branch-weight (right-branch m))))
        (define (balance-branch? branch)
                (let ((next (branch-structure branch)))
                     (if (have-mobile? branch)
                         (balance? next)
                         #t)))
        (if (pair? mobile)
            (if (= (left-moment mobile) (right-moment mobile))
                (and (balance-branch? (left-branch mobile)) (balance-branch? (right-branch mobile)))
                #f)
            #t))
```

### 练习2.30

> 请定义一个与练习2.21中square-list过程类似的square-tree过程。也就是说，他应该具有下面的行为：
> ```lisp
> (square-tree
>    (list 1
>          (list 2 (list 3 4) 5)
>          (list 6 7)))
> (1 (4 (9 16) 25) (36 49))
> ```
> 请以两种方式定义square-tree，直接定义(即不适用任何高阶函数)，以及使用map和递归定义。

```lisp
(define (square-tree1 tree)
        (map (lambda (sub-tree)
                     (if (pair? sub-tree)
                         (square-tree1 sub-tree)
                         (square sub-tree)))
              tree))

(define (square-tree2 tree)
        (cond ((null? tree) tree)
              ((not (pair? tree)) (square tree))
              (else (cons (square-tree2 (car tree))
                          (square-tree2 (cdr tree))))))
```

### 练习2.31

> 将你在练习2.30做出的解答进一步抽象，做出一个过程，使他的性质能保证以下面的形式定义square-tree：
`(define (square-tree tree) (tree-map square tree))`

```lisp
(define (tree-map proc tree)
        (map (lambda (sub-tree)
                     (if (pair? sub-tree)
                         (tree-map proc sub-tree)
                         (proc sub-tree)))
              tree))
```

### 练习2.32

> 我们可以将一个集合表示为一个元素互不相同的表，因此就可以将一个集合的所有子集表示为表的表。例如，假定集合为(1 2 3)，它的所有子集的集合就是(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))。请完成下面的过程定义，他生成一个集合的所有子集的集合。请解释它为什么能完成这一工作。
> ```lisp
> (define (subsets s)
>         (if (null? s)
>             (list (list))
>             (let ((rest (subsets (cdr s))))
>                  (append rest (map <??> rest)))))
> ```

```lisp
(define (subsets s)
        (if (null? s)
            (list nil)
            (let ((rest (subsets (cdr s))))
                 (append rest (map (lambda (x)
                                           (cons (car s) x))
                                   rest)))))
```

rest：不包含元素(car s)的s的子集((cdr s)的子集)
`(map (lambda (x) (cons (car s) x)) rest)`：包含元素(car s)的子集。(将rest的每个元素与(car s)组合成新的集合)

### 练习2.33

> 请填充下面缺失的表达式，完成将一些基本的表操作看作累积的定义：
> ```lisp
> (define (map p sequence)
>         (accumulate (lambda (x y) <??>) nil sequence))
> (define (append seq1 seq2)
>         (accumulate cons <??> <??>))
> (define (length sequence)
>         (accumulate <??> 0 sequence))
> ```

```lisp
(define (map p sequence)
        (accumulate (lambda (x y) (cons (p x) y)) 
                    (list)
                    sequence))

(define (append seq1 seq2)
        (accumulate cons seq2 seq1))

(define (length sequence)
        (accumulate (lambda (x y)
                            (+ 1 y)) 
                    0
                    sequence))
```

### 练习2.34

> 对于x的某个给定值，求出一个多项式在x的值，也可以形式化为一种累积。假定需要求下面多项式的值：
$a_nx^n+a_{n-1}x^{n-1}+...+a_1x+a_0$
采用著名的Horner规则，可以构造出下面的计算：
$(...(a_nx+a_n)x+...+a_1)x+a_0$
换句话说，我们可以从$a_n$开始，乘以x，再加上$a_{n-1}$,乘以x，如此下去，直到处理完$a_0$。请填充下面的模板，做出一个利用Horner规则求值多项式的过程。假定多项式的系数安排在一个序列里，从$a_0$直至$a_n$
> ```lisp
> (define (horner-eval x coefficient-sequence)
>         (accumulate (lambda (this-coeff higher-terms) <??>)
>                     0
>                     coefficient-sequence))
> ```
> 例如为了计算$1+3x+5x^3+x^5$在$x=2$的值，你需要求值：
`(horner-eval 2 (list 1 3 0 5 0 1))`

```lisp
(define (horner-eval x coefficient-sequence)
        (accumulate (lambda (this-coeff higher-terms)
                            (+ this-coeff
                               (* x higher-terms)))
                    0
                    coefficient-sequence))
```

### 练习2.35

> 将2.2.2节的count-leaves重新定义为一个累积：
> ```lisp
> (define (count-leaves t)
>         (accumulate <??> <??> (map <??> <??>))
> ```

```lisp
(define (count-leaves t)
        (accumulate (lambda (x y) (+ x y)) 
                    0
                    (map (lambda (sub-tree)
                                 (if (pair? sub-tree)
                                     (count-leaves sub-tree)
                                     1))
                         t)))
```

```lisp
;;子树的叶子数
(lambda (sub-tree)
        (if (pair? sub-tree)
            (count-leaves sub-tree)
            1))
```

### 练习2.36

> 过程accumulate-n与accumulate类似，除了它的第三个参数是一个序列的序列，假定其中每个序列的元素个数相同。它用指定的积累过程去组合起所有序列的第一个元素，而后是所有序列的第二个元素，并如此做下去，返回得到的所有结果的序列。例如，如果s是包含着4个序列的序列((1 2 3) (4 5 6) (7 8 9) (10 11 12))，那么(accumulate + 0 s)的值就应该是序列(22 26 30)。请填充下面accumulate-n定义中所缺失的表达式：
> ```lisp
> (define (accumulate-n op init seqs)
>         (if (null? (car seqs))
>             (list)
>             (cons (accumulate op init <??>)
>                   (accumulate-n op init <??>))))
> ```

```lisp

(define (accumulate-n op init seqs)
        (if (null? (car seqs))
            (list)
            (cons (accumulate op init (map car seqs))
                  (accumulate-n op init (map cdr seqs)))))
```

`(accumulate op init (map car seqs)`:序列第一个元素组成的新序列的累积

### 练习2.37

> 嘉定我们将向量$v=(v_i)$表示为数的序列，将矩阵$m=(m_{ij})$表示为向量(矩阵行)的序列。例如，矩阵：
$
\begin{vmatrix}
1&2&3&4 \\
4&5&6&6 \\
6&7&8&9
\end{vmatrix}
$
用序列((1 2 3 4) (4 5 6 6) (6 7 8 9))表示。对于这种表示，我们可以用序列操作简洁地表达基本的矩阵与向量运算。这些运算(任何有关矩阵代数的书里都有描述)如下：
(dot-product v w)  返回和$\sum_iv_iw_i$;
(matrix-*-vector m v) 返回向量t，其中：$t_i=\sum_jm_{ij}v_j$;
(matrix-*-matrix m n) 返回矩阵p，其中：$p_{ij}=\sum_km_{ik}n{kj}$
(transpose m) 返回矩阵n，其中: $n_{ij}=m_{ji}$
我们可以将点积(dot product)定义为：
> ```lisp
> (define (dot-product v w)
>         (accumulate + 0 (map * v w)))
> ```
> 请填充下面过程里缺失的表达式，它们计算出其他的矩阵运算结果(过程accumulate-n在练习2.36中定义)。
> ```lisp
> (define (matrix-*-vector m v)
>         (map <??> m))
> (define (transpose mat)
>         (accumulate-n <??> <??> mat))
> (define (matrix-*-matrix m n)
>         (let ((cols (transpose n)))
>              (map <??> m)))
> ```

```lisp
(define (matrix-*-vector m v)
        (map (lambda (x)
                     (dot-product x v))
             m))

(define (transpose mat)
        (accumulate-n cons (list) mat))

(define (matrix-*-matrix m n)
        (let ((cols (transpose n)))
             (map (lambda (x)
                          (accumulate cons
                                      (list)
                                      (map (lambda (y)
                                                   (dot-product x y))
                                            cols))) m)))
```

### 练习2.38

> 过程accumulate也被称为fold-right，因为它将序列的第一个元素组合到右边所有元素的组合结果上。也有一个fold-left，它与fold-right类似，但却是按照相反方向去操作各个元素：
> ```lisp
> (define (fold-left op initial sequence)
>         (define (iter result rest)
>                 (if (null? rest)
>                     result
>                     (iter (op result (car rest))
>                           (cdr rest))))
>        (iter initial sequence))
> ```
> 下面各表达式的值是什么？
> ```lisp
> (fold-right / 1 (list 1 2 3))
> (fold-left / 1 (list 1 2 3))
> (fold-right list nil (list 1 2 3))
> (fold-left list nil (list 1 2 3))
> ```
> 如果要求某个op时保证fold-right和fold-left对任何序列都产生同样的结果，请给出op应该满足的性质。

1:3/2
(a / 1 (1 2 3))
(/ 1 (a / 1 (2 3)))
(/ 1 (/ 2 (a / 1 (3))))
(/ 1 (/ 2 (/ 3 (a / 1 nil))))
(/ 1 (/ 2 (/ 3 1)))
(/ 1 (/ 2 3))
(/ 1 2/3)
(3/2)
2:1/6
(iter 1 (1 2 3))
(iter (/ 1 1) (2 3))
(iter 1 (2 3))
(iter (/ 1 2) (3))
(iter 1/2 (3))
(iter (/ 1/2 3) ())
(iter (1/6) ())
(1/6)
3:(1 (2 (3 ())))
(a list () (1 2 3))
(list 1 (a list () (2 3)))
(list 1 (list 2 (a list () (3))))
(list 1 (list 2 (list 3 (a list () ()))))
(list 1 (list 2 (list 3 ()))
(list 1 (list 2 (3 ())))
(list 1 (2 (3 ())))
(1 (2 (3 ())))
4:(((() 1) 2) 3)
(iter () (1 2 3))
(iter (list () 1) (2 3))
(iter (() 1) (2 3))
(iter (list (() 1) 2) (3))
(iter ((() 1) 2) (3))
(iter (list ((() 1) 2) 3) ())
(iter (((() 1) 2) 3) ())
(((() 1) 2) 3)
(op x y)=(op y x)

### 练习2.39

> 基于练习2.38的fold-right和fold-left完成reverse(练习2.18)下面的定义：
> ```lisp
> (define (reverse sequence)
>         (fold-right (lambda (x y) <??>) nil sequence))
> (define (reverse sequence)
>         (folde-left (lambda (x y) <??>) nil sequence))
> ```

```lisp
(define (reverse1 sequence)
        (fold-right (lambda (x y)
                            (append y (list x))) (list) sequence))

(define (reverse2 sequence)
        (fold-left (lambda (x y)
                            (append (list y) x)) (list) sequence))
```

(op x y)在fold-right中，x表示左值(左侧元素)，y表示对x右边所有值应用op的结果；在fold-left中，x表示对y左边所有值应用op的结果，y表示右值(右侧元素)。

### 2.40

> 请定义过程unique-pairs,给它整数n，它产生出序对(i,j)，其中$1\leqslant j\leqslant i\leqslant n$。请用unique-pairs去简化上面prime-sum-pairs的定义。

```lisp
(define (unique-pairs n)
        (flatmap (lambda (i)
                         (map (lambda (j)
                                      (list i j))
                                      (enumerate-interval (+ i 1) n)))
                 (enumerate-interval 1 n)))

(define (unique-pairs n)
        (flatmap (lambda (i)
                         (map (lambda (j)
                                      (list i j))
                                      (enumerate-interval 1 (- i 1))))
                 (enumerate-interval 1 n)))

(define (prime-sum-pairs n)
        (map make-pair-sum
             (filter prime-sum? (unique-pairs n))))
```

### 练习2.41

> 请定义一个过程，它能产生出所有小于等于给定整数n的正的相异正整数i，j，k的有序三元组，使每一个三元组的三个元之和等于给定的整数s。

```lisp
(define (unique-triples n)
        (flatmap (lambda (x)
                         (map (lambda (y)
                                      (cons x y))
                              (unique-pairs (- x 1))))
                 (enumerate-interval 1 n)))


(define (ns-pairs n s)
        (define (sum-eq-s? l)
        (= (+ (car l) (cadr l) (caddr l))
          s))
        (filter sum-eq-s? (unique-triples n)))
```

### 练习2.42

> "八皇后谜题"问的是怎样将八个皇后摆在国际象棋盘上，使得任意一个皇后都不能攻击另一个皇后(也就是说，任意两个皇后都不在同一行、同一列或者同一对角线上)。一个可能的解如图2-8所示。解决这一谜题的一种方法按一个方向处理棋盘，每次在每一列里放一个皇后。如果现在已经放好了k-1个皇后，第k个皇后就必须放在不会被已在棋盘上的任何皇后攻击的位置上。我们可以递归地描述这一过程：假定我们已经生成了在棋盘上的前k-1列中放置k-1个皇后的所有可能方式，现在需要的就是对其中的每种方式，生成出将下一个皇后放在第k列中每一行的扩充集合。而后过滤它们，只留下能使位于第k列的皇后与其它皇后相安无事的那些扩充。这样就能产生出将k个皇后放置在前k列的所有格局的序列。继续这一过程，我们就能产生出这一谜题的所有解，而不是一个解。
将这一解法实现为一个过程queens，令它返回在n*n棋盘上放n个皇后的所有解的序列。queens内部的过程queen-cols，返回在棋盘的前k列中放皇后的所有格局的序列。
> ```lisp
> (define (queens board-size)
>         (define (queen-cols k)
>                 (if (= k 0)
>                     (list enpty-board)
>                     (filter (lambda (positions) (safe? k positions))
>                             (flatmap (lambda (rest-of-queens)
>                                              (map (lambda (new-row)
>                                                           (adjoin-position new-row k rest-of-queens))
>                                                   (enumerate-interval 1 board-size))
>                                      (queen-cols (- k 1)))))))
>         (queen-cols board-size))
> ```
> 这个过程里的rest-of-queens是在前k-1列放置k-1个皇后的一种方式，new-row是在第k列放置所考虑的行编号。请完成这一程序，为此需要实现一种棋盘格局集合的表示方式，还要实现过程adjoin-position,它将一个新的行列格局加入一个格局集合；empty-board，它表示空的格局集合。你还需要写出过程safe？，它能确定在一个格局中，在第k列的皇后相对于其它列的皇后是否为安全的(请注意，我们只需检查新皇后是否安全——其他皇后已经保证相安无事了)。

```lisp
(define empty-board `())

(define (adjoin-position new-row k rest-of-queens)
        (cons new-row rest-of-queens))

(define (safe? k positions)
        (let ((num (car positions)))
              (define (iter-safe? n items r)
                      (if (not r)
                          #f
                          (if (null? items)
                              #t
                              (iter-safe? (+ 1 n) 
                                          (cdr items) 
                                          (and (not (= (car items) (+ num n)))
                                               (not (= (car items) (- num n)))
                                               (not (= (car items) num)))))))
              (iter-safe? 1 (cdr positions) #t)))
```
程序运行的结果是给出一个list的集合，其中的每个list都是一个解，由8个数组成。其中每个元素的值表示行，元素在列表中的位置表示列。(5 7 2 6 3 1 4 8)中的5表示位置第8列的第5行。
(adjoin-position new-row k rest-of-queens)的实现方式表示每当新增一列k时，把表示这列中每一行的元素的数值new-row放在已有结果的前面，也就是说，结果给出的列的顺序是逆序的(col8 col7....col1)
(safe? k positions)：(car postions)表示第k列上的皇后的位置，检查它相对于(cdr postions)中所有的皇后是否安全。对(cdr postions)进行递归的检查，当相对于某一列的皇后不安全时，直接返回#f。n表示需要检查的列与k的距离。当检查完成时，n=k-1，同时剩余的序列为空。

### 练习2.43

> Louis Reasoner在做练习2.42时遇到了麻烦，他的queens过程看起来能行，但却运行得极慢(Louis居然无法忍耐到它解出6*6棋盘的问题)。当Louis请Eva Lu Ator帮忙时，她指出他在flatmap里交换了嵌套映射的顺序，将它写成了：
> ```lisp
> (flatmap (lambda (new-row)
>                  (map (lambda (rest-of-queens)
>                               (adjoin-position new-row k rest-of-queens))
>                       (queen-cols (- k 1))))
>          (enumerate-interval 1 board-size))
> ```
> 请解释一下，为什么这样交换顺序会使程序运行得非常慢。估计一下，用Louis的程序去解决八皇后问题大约需要多少时间，假定练习2.42中的程序需要用时间T求解这一难题。

对于2.42的程序，每执行一次flatmap，需要计算一次(queen-cols (- k 1)),计算(length (queen-cols (- k 1)))次(enumerate-interval 1 board-size)).Louis的程序则反过来，每执行一次flatmap，需要计算一次(enumerate-interval 1 board-size),计算(length (enumerate-interval 1 board-size))次(queen-cols (- k 1))。大约需要$T*{board-size}$