<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

* [第二章 构造数据抽象](#第二章-构造数据抽象)
	* [2.1 数据抽象导引](#21-数据抽象导引)
		* [2.1.1 实例：有理数的算术运算](#211-实例有理数的算术运算)
			* [序对](#序对)
			* [有理数的表示](#有理数的表示)
		* [2.1.2 抽象屏障](#212-抽象屏障)
		* [2.1.3 数据意味着什么](#213-数据意味着什么)
		* [2.1.4 扩展练习：区间算术](#214-扩展练习区间算术)
	* [2.2 层次性数据和闭包性质](#22-层次性数据和闭包性质)
		* [2.2.1 序列的表示](#221-序列的表示)
			* [表操作](#表操作)
		* [对表的映射](#对表的映射)

<!-- /code_chunk_output -->

# 第二章 构造数据抽象

## 2.1 数据抽象导引

> 数据抽象是一种方法学，将一个复合数据对象的使用与该数据对象怎样由更基本的数据对象构造起来的细节隔离开。
> 程序中使用数据时，除了完成当前工作所必须的东西外，不对数据做任何多余的假设。
> 数据表示的定义与程序使用数据的方式无关。

> 选择函数：数据的使用方式。
> 构造函数：数据表示的定义。

### 2.1.1 实例：有理数的算术运算

假定构造函数和选择函数：
> `(make-rat <n> <d>)`返回一个有理数，分子是n，分母是d。
> `(numer <x>)`返回有理数x的分子
> `(denom <x>)`返回有理数x的分母

通过这三个过程可以根据有理数运算规则实现有理数的加减乘除和相等判断。

#### 序对

```lisp
(cons a b)

(define x (cons a b))
(car x)
=>a
(cdr x)
=>b
```
> 一个序对也是一个数据对象，可以向基本数据对象一样给她一个名字并且操作它，也可以用cons去构造元素本身就是序对的序对。
从序对构造起来的数据对象称为表结构数据。

#### 有理数的表示

```lisp
(define (make-rat n d) (cons n d))
(define (numer x) (car x))
(define (denom x) (cdr x))
```

### 2.1.2 抽象屏障

> 一般而言，数据抽象的基本思想就是为每一类数据对象标识出一组操作，使得对这类数据对象的所有操作都可以基于它们表述，而且在操作这些数据对象时也只使用它们。

> 表示方式的选择会对操作它的程序产生影响。

> 数据抽象方法是我们能推迟决策的时间，而又不会阻碍系统其他部分的工作进展。

### 2.1.3 数据意味着什么

> 一般而言，我们总可以将数据定义为一组适当的选择函数和构造函数，以及为使这些过程成为一套合法表示，他们就必须满足的一组特定条件。
> 数据的过程性表示。数据(结构)可以由一组满足对数据操作的过程定义。

### 2.1.4 扩展练习：区间算术

## 2.2 层次性数据和闭包性质

盒子和指针表示方式
![(cons 1 2)盒子和指针表示](/img/盒子和指针表示.PNG)

闭包性质
> 一般说，某种组合数据对象的操作满足闭包性质，那就是说，通过它组合起数据对象得到的结果本身还可以通过同样的操作再进行组合。
**对比编程语言实现的闭包**

### 2.2.1 序列的表示

序列：
> 一批数据对象的一种有序汇集
`(list <a1> <a2> <a3>...<an>)`

#### 表操作

```lisp
(list-ref items n)
(length items)
(append list1 list2)
```

#### 对表的映射

> 将某种变换应用于一个表的所有元素，得到所有结果构成的表。
`(map proc items)`
map帮我们建起了一层抽象屏障，将实现表变换的过程的实现，与如何提取表中元素以及组合结果的细节隔离开。

### 2.2.2 层次性结构

#### 树

可以将表结构看作树

```lisp
(define (count-leaves x)
        (cond ((null? x) 0)
              ((not (pair? x)) 1)
              (else (+ (count-leaves (car x))
                       (count-leaves (cdr x))))))
```

#### 对树的映射

```lisp
(deffine (scale-tree tree factor)
         (map (lambda (sub-tree)
                      (if (pair? sub-tree)
                          (scale-tree sub-tree factor)
                          (* sub-tree factor)))
          tree))
```

### 2.2.3 序列作为一种约定的界面

枚举器-过滤器-映射(转换装置)-累积器

#### 序列操作

映射：(map proc list)
(map 应用于元素的操作 表)
过滤器：(filter predicate sequence)
(filter 应用于元素的判断 序列)
累积器：(accumulate op initial sequence)
(accumulate 累积操作 初始值 序列)

```lisp
(define (accumulate op initial sequence)
        (if (null? sequence)
            initial
            (op (car sequence)
                (accumulate op initial (cdr sequence)))))
```

(op x y):递归过程，将op应用于表的第一个元素和剩余元素应用op的结果。

#### 嵌套映射

```lisp
(define (flatmap proc seq)
        (accumulate append nil (map proc seq)))
```

### 2.2.4 实例：一个图形语言

#### 图形语言

painter：画家，画出一个正好放到某个框架的图像。
beside：**从两个画家出发，产生出一个画家。**将第一个画家的图像画在框架的左边的一半里，第二个画家的图像画在框架右边的一半里。
below：**从两个画家出发，产生出一个画家。**将第一个画家的图像画在第二个画家的图像之下。
flip-vert：**从一个画家出发，**产生出一个将该画家所画图像上下颠倒画出的画家。
flip-horiz：**从一个画家出发，**产生的画家将原画家的图像左右反转后画出。

组合画家：画家在语言的组合方式下是封闭的。

#### 高阶操作

抽象出画家的各种组合操作的模式。
以画家操作作为参数，创建出新的画家操作。

#### 框架

构造函数make-frame，从三个向量出发做出一个框架
选择函数：origin-frame、edge1-frame、edge2-frame

#### 画家

给定一个框架f，作为画家p的实际参数，就能产生出f中p的图像。

#### 画家的变换和组合

#### 强健设计的语言层次

分层设计：一个复杂的系统应该通过一系列的层次构造出来，为了描述这些层次，需要使用一系列的语言。在分层设计中，每个层次上所用的语言都提供了一些基本元素、组合手段，还有对该层次中适当细节做抽象的手段。

## 2.3 符号数据

### 2.3.1 引号

> 一个单引号的意义就是引用下一个对象
引号可以用于复合对象
`(memq symbol list)`：返回符号第一次出现开始的子表，如果未包含在表中则返回#f

> ```lisp
> (list 'a 'b)
> (a b)
> (car '(a b c))
> a
> (eq? 'symbol1 'symbol2)
> #f
> (memq 'item2 '(list item1 item2 item3))
> (item2 item3)
> ```

### 2.3.2 实例：符号求导

过程以一个代数表达式和一个变量作为参数，返回这个表达式相对于该变量的导数。

#### 对抽象数据的求导程序

基于抽象数据表述的过程，无论我们如何选择数据的具体表示，只要设计了一组正确的选择函数和构造函数，这个过程就可以工作。

#### 代数表达式的表示

`(symbol? x)`x是否是符号。

### 2.3.3 实例：集合的表示

union-set：两个集合的并集
intersection-set：两个集合的交集
element-of-set?：元素是不是集合的成员
adjoin-set：将新元素加入原集合

#### 集合作为未排序的表

#### 集合作为排序的表

#### 集合作为二叉树