# 第一章  构造过程抽象

## 1.1 程序设计的基本元素

***

### 1.1.0

#### 程序设计中需要处理两类要素：过程和数据。

***

### 1.1.1  表达式

#### 前缀表示

将运算符放在所有运算对象的左边。

- 完全适用于可能带有任意个实参的过程

   `(+ 1 2 3 4)`
- 可以直接扩充，允许组合式嵌套

   `(+ (+ 1 2) (+ 3 4))`

#### 解释器运作方式

从终端读入一个表达式，对这个表达式求值，而后打印出得到的结果。

解释器运行在一个**读入-求值-打印**循环中。

***

### 1.1.2 命名和环境

名字的标识符称为**变量**。变量的值就是它所对应的对象

 **define：** 允许用一个简单的名字去引用一个组合运算的结果。

#### 环境

解释器必须维护某种存储能力，以便保持有关的名字-值对偶的轨迹，这种存储被称为**环境**。

***

### 1.1.3 组合式的求值

#### 解释器的工作过程：

*求值一个组合式*

1. 求值该组合式的各个子表达式

2. 将运算符作用于相应的实际参数

> *例：*
>
> `(+ (+ 1 2) (+ 3 4))`
>
> 首先求值`(+ 1 2)`得**3**和`(+ 3 4)`得**7**，
>
> 然后求值`(+ 3 7)`


#### 递归

> 他在自己的工作步骤中，包含着调用这个规则本身的需要。

一个过程是递归的，意味着这个过程可以在内部调用自身。

#### 树形积累

用树形表示组合式的求值过程。

#### 特殊形式

每个特殊形式都有其滋生的求值规则。

`(define x 1)`

***

### 1.1.4 复合过程

#### 过程
> 定义：
>``` lisp
> (define (<name> <formal parameters>) <body>)
> (define (<函数名> <参数>) <函数体>)
>```
> <span id="square"></span>
>```lisp
> (define (square x) (* x x))
>```
***

### 1.1.5 过程应用的代换模型

#### 代换模型

> **过程**
>
> $(a+1)^2+(2a)^2$
>

> ``` lisp
> (define (square x) (* x x))
> ```

>
> ``` lisp
> (define (sum-of-squares x y)
>                       (+ (square x) (square y)))
>```
> ``` lisp
> (define (f a)
>        (sum-of-squares (+ a 1) (* a 2)))
> ```

> 代换过程：
>
> **应用序**：`先求值参数而后应用`
>
> 1. (f 5)
>
> 2. (sum-of-squares (+ a 1) (* a 2))
>
> 3. (sum-of-squares (+ 5 1) (* 5 2))
>
> 4. (sum-of-squares (6 10))
>
> 5. (+ (square 6) (square 10))
>
> 6. (+ (* 6 6) (* 10 10))
>
> 7. (+ 36 100)
>
> 8. 136
>
> **正则序**：`完全展开而后归约`
>
> *展开：*
>
> 1. (f 5)
>
> 2. (sum-of-squares (+ 5 1) (* 5 2))
>
> 3. (+ (square (+ 5 1)) (square (* 5 2)))
>
> 4. (+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))
>
> *归约:*
>
> 5. (+ (* 6 6) (* 10 10))
>
> 6. (+ 36 100)
>
> 7. 136

***

### 1.1.6 条件表达式和谓词

#### 条件表达式

> 定义：
>``` lisp
> (cond (<p1> <e1>)
>       (<p2> <e2>)
>       ...
>       (<pn> <en>))
>```
> \<pn\> 谓词

#### 谓词：返回真或假的过程

> `> 、 <、 =`
>
> `(and <e1> <e2> ... <en>)`
>
> `(or <e1> <e2> ... <en>)`
>
> `(not <e>)`

#### if

> 定义：
>``` lisp
> (if <predicate> <consequent> <alternative>)
>```

***

### 1.1.7 实例：采用牛顿法求平方根

数学函数与计算机过程之间的一个重要的差异，就是过程必须是有效可行的。对计算机过程而言，我们通常关心行动性的描述（事情怎么做）。

#### 牛顿法求平方根的原理

> 假设y是x的平方根的一个猜测值，那么可以通过公式 $ y^{'}=\dfrac{(y+\dfrac{x}{y})}{2} $得到更好的猜测值$y^{'}$

流程图如下：
```flow
st=>start: 计算x的平方根
op_1=>operation: 获得猜测值guess
sub2=>subroutine: 判断猜测值是否正确(足够好)
                  (good-enough? guess x)
sub1=>subroutine: 获取更好的猜测值
                 (improve guess x)
cond=>condition: good-enough?
e=>end: 得到x的平方根
st->op_1->sub2->cond
cond(yes)->e
cond(no)->sub1->sub2
```
代码：
> ```lisp
> ;;;sqrt-iter是一个递归的过程，不断调用自身来获取更好的猜测值，直到猜测值满足要求。
> (define (sqrt-iter guess x)
>         (if (good-enough? guess x)
>         guess
>         (sqrt-iter (improve guess x)
>                    x)))
> (define (improve guess x)
>         (average guess (/ x guess)))
>```
> <span id="good-enough?"></span>
>```lisp
> (define (good-enough? guess x)
>         (< (abs (- x (square guess)))
>           0.001))
> ;;;平均值
> (define (average x y)
>         (/ (+ x y) 2))
> ```
> [(square x)](#square)参见1.1.4中定义


要使程序运行，必须提供一个初始猜测值。使用1作为初始值。

> ```lisp
> (define (sqrt x)
>         (sqrt-iter 1.0 x))
> ```

***

### 1.1.8过程作为黑箱的抽象

一个过程定义应该能隐藏一些细节，过程的使用者从其他程序员哪里作为一个黑箱接受过程，在使用过程是，应该不需要去弄清过程是如何实现的。

#### 局部名
过程的形式参数必须局部域有关的过程体，过程的形式参数不能与过程外的相同参数名的参数混淆。

- 变量
  - 约束变量：形式参数的具体名字对过程的实现没有影响，这种名字称为**约束变量**。
  - 自由变量：如果一个变量不是被约束的，我们就称它为自由的。

#### 内部定义和块结构

**内部定义**

允许一个过程里带有一些内部定义，使它们局部于这一过程。嵌套的定义必须出现在过程体之前。
>```lisp
> (define (sqrt x)
>   (define (good-enough? guess x)
>           (< (abs (- (square guess) x)) 0.001))
>   (define (improve guess x)
>           (average guess (/ x guess)))
>   (define (sqrt-iter guess x)
>           (if (good-enough? guess x)
>               guess
>               (sqrt-iter (improve guess x) x)))
>   (sqrt-iter 1.0 x))
>```

这种嵌套定义被称为**块结构**
> 在上面的(sqrt x)过程中，x在sqrt中的定义中是受约束的，过程good-enough?、improve和sqrt-iter也都定义在sqrt中，因此没必要将x在这些过程中显式传递。可以将x作为内部定义的自由变量。
> 在外围的sqrt被调用时，x由实际参数得到自己的值，这种方式称为**词法作用域**
>
>```lisp
> (define (sqrt x)
>   (define (good-enough? guess)
>           (< (abs (- (square guess) x)) 0.001))
>   (define (improve guess)
>           (average guess (/ x guess)))
>   (define (sqrt-iter guess)
>           (if (good-enough? guess)
>               guess
>               (sqrt-iter (improve guess))))
>   (sqrt-iter 1.0))
>```
>> **x对于sqrt是约束变量，对于good-enough?、improve和sqrt-iter是自由变量。**
***

## 1.2过程与它们所产生的计算