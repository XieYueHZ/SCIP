<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

* [第一章  构造过程抽象](#第一章-构造过程抽象)
	* [1.1 程序设计的基本元素](#11-程序设计的基本元素)
		* [1.1.0](#110)
		* [1.1.1  表达式](#111-表达式)
			* [前缀表示](#前缀表示)
			* [解释器运作方式](#解释器运作方式)
		* [1.1.2 命名和环境](#112-命名和环境)
			* [环境](#环境)
		* [1.1.3 组合式的求值](#113-组合式的求值)
			* [解释器的工作过程：](#解释器的工作过程)
			* [递归](#递归)
			* [树形积累](#树形积累)
			* [特殊形式](#特殊形式)
		* [1.1.4 复合过程](#114-复合过程)
			* [过程](#过程)
		* [1.1.5 过程应用的代换模型](#115-过程应用的代换模型)
			* [代换模型](#代换模型)
		* [1.1.6 条件表达式和谓词](#116-条件表达式和谓词)
			* [条件表达式](#条件表达式)
			* [谓词：返回真或假的过程](#谓词返回真或假的过程)
			* [if](#if)
		* [1.1.7 实例：采用牛顿法求平方根](#117-实例采用牛顿法求平方根)
			* [牛顿法求平方根的原理](#牛顿法求平方根的原理)
		* [1.1.8过程作为黑箱的抽象](#118过程作为黑箱的抽象)
			* [局部名](#局部名)
			* [内部定义和块结构](#内部定义和块结构)
		* [1.2过程与它们所产生的计算](#12过程与它们所产生的计算)
			* [1.2.1 线性的递归和迭代](#121-线性的递归和迭代)
			* [1.2.2 树形递归](#122-树形递归)
			* [实例：换零钱方式的统计](#实例换零钱方式的统计)
			* [1.2.3增长的阶](#123增长的阶)
			* [1.2.4 求幂](#124-求幂)
			* [1.2.5 最大公约数](#125-最大公约数)
			* [1.2.6 实例：素数检测](#126-实例素数检测)

<!-- /code_chunk_output -->

# 第一章  构造过程抽象

## 1.1 程序设计的基本元素

***

### 1.1.0

程序设计中需要处理两类要素：过程和数据。

***

### 1.1.1  表达式

#### 前缀表示

将运算符放在所有运算对象的左边。

- 完全适用于可能带有任意个实参的过程

   `(+ 1 2 3 4)`
- 可以直接扩充，允许组合式嵌套

   `(+ (+ 1 2) (+ 3 4))`

#### 解释器运作方式

从终端读入一个表达式，对这个表达式求值，而后打印出得到的结果。

解释器运行在一个**读入-求值-打印**循环中。

***

### 1.1.2 命名和环境

名字的标识符称为**变量**。变量的值就是它所对应的对象

 **define：** 允许用一个简单的名字去引用一个组合运算的结果。

#### 环境

解释器必须维护某种存储能力，以便保持有关的名字-值对偶的轨迹，这种存储被称为**环境**。

***

### 1.1.3 组合式的求值

#### 解释器的工作过程：

*求值一个组合式*

1. 求值该组合式的各个子表达式

2. 将运算符作用于相应的实际参数

> *例：*
>
> `(+ (+ 1 2) (+ 3 4))`
>
> 首先求值`(+ 1 2)`得**3**和`(+ 3 4)`得**7**，
>
> 然后求值`(+ 3 7)`


#### 递归

> 他在自己的工作步骤中，包含着调用这个规则本身的需要。

一个过程是递归的，意味着这个过程可以在内部调用自身。

#### 树形积累

用树形表示组合式的求值过程。

#### 特殊形式

每个特殊形式都有其滋生的求值规则。

`(define x 1)`

***

### 1.1.4 复合过程

#### 过程
> 定义：
>``` lisp
> (define (<name> <formal parameters>) <body>)
> (define (<函数名> <参数>) <函数体>)
>```
> <span id="square"></span>
>```lisp
> (define (square x) (* x x))
>```
***

### 1.1.5 过程应用的代换模型

#### 代换模型

> **过程**
>
> $(a+1)^2+(2a)^2$
>

> ``` lisp
> (define (square x) (* x x))
> ```

>
> ``` lisp
> (define (sum-of-squares x y)
>                       (+ (square x) (square y)))
>```
> ``` lisp
> (define (f a)
>        (sum-of-squares (+ a 1) (* a 2)))
> ```

> 代换过程：
>
> **应用序**：`先求值参数而后应用`
>
> 1. (f 5)
>
> 2. (sum-of-squares (+ a 1) (* a 2))
>
> 3. (sum-of-squares (+ 5 1) (* 5 2))
>
> 4. (sum-of-squares (6 10))
>
> 5. (+ (square 6) (square 10))
>
> 6. (+ (* 6 6) (* 10 10))
>
> 7. (+ 36 100)
>
> 8. 136
>
> **正则序**：`完全展开而后归约`
>
> *展开：*
>
> 1. (f 5)
>
> 2. (sum-of-squares (+ 5 1) (* 5 2))
>
> 3. (+ (square (+ 5 1)) (square (* 5 2)))
>
> 4. (+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))
>
> *归约:*
>
> 5. (+ (* 6 6) (* 10 10))
>
> 6. (+ 36 100)
>
> 7. 136

***

### 1.1.6 条件表达式和谓词

#### 条件表达式

> 定义：
>``` lisp
> (cond (<p1> <e1>)
>       (<p2> <e2>)
>       ...
>       (<pn> <en>))
>```
> \<pn\> 谓词

#### 谓词：返回真或假的过程

> `> 、 <、 =`
>
> `(and <e1> <e2> ... <en>)`
>
> `(or <e1> <e2> ... <en>)`
>
> `(not <e>)`

#### if

> 定义：
>``` lisp
> (if <predicate> <consequent> <alternative>)
>```

***

### 1.1.7 实例：采用牛顿法求平方根

数学函数与计算机过程之间的一个重要的差异，就是过程必须是有效可行的。对计算机过程而言，我们通常关心行动性的描述（事情怎么做）。

#### 牛顿法求平方根的原理

> 假设y是x的平方根的一个猜测值，那么可以通过公式 $ y^{'}=\dfrac{(y+\dfrac{x}{y})}{2} $得到更好的猜测值$y^{'}$

流程图如下：
```flow
st=>start: 计算x的平方根
op_1=>operation: 获得猜测值guess
sub2=>subroutine: 判断猜测值是否正确(足够好)
                  (good-enough? guess x)
sub1=>subroutine: 获取更好的猜测值
                 (improve guess x)
cond=>condition: good-enough?
e=>end: 得到x的平方根
st->op_1->sub2->cond
cond(yes)->e
cond(no)->sub1->sub2
```
代码：
> ```lisp
> ;;;sqrt-iter是一个递归的过程，不断调用自身来获取更好的猜测值，直到猜测值满足要求。
> (define (sqrt-iter guess x)
>         (if (good-enough? guess x)
>         guess
>         (sqrt-iter (improve guess x)
>                    x)))
> (define (improve guess x)
>         (average guess (/ x guess)))
>```
> <span id="good-enough?"></span>
>```lisp
> (define (good-enough? guess x)
>         (< (abs (- x (square guess)))
>           0.001))
> ;;;平均值
> (define (average x y)
>         (/ (+ x y) 2))
> ```
> [(square x)](#square)参见1.1.4中定义


要使程序运行，必须提供一个初始猜测值。使用1作为初始值。

> ```lisp
> (define (sqrt x)
>         (sqrt-iter 1.0 x))
> ```

***

### 1.1.8过程作为黑箱的抽象

一个过程定义应该能隐藏一些细节，过程的使用者从其他程序员哪里作为一个黑箱接受过程，在使用过程是，应该不需要去弄清过程是如何实现的。

#### 局部名
过程的形式参数必须局部域有关的过程体，过程的形式参数不能与过程外的相同参数名的参数混淆。

- 变量
  - 约束变量：形式参数的具体名字对过程的实现没有影响，这种名字称为**约束变量**。
  - 自由变量：如果一个变量不是被约束的，我们就称它为自由的。

#### 内部定义和块结构

**内部定义**

允许一个过程里带有一些内部定义，使它们局部于这一过程。嵌套的定义必须出现在过程体之前。
>```lisp
> (define (sqrt x)
>   (define (good-enough? guess x)
>           (< (abs (- (square guess) x)) 0.001))
>   (define (improve guess x)
>           (average guess (/ x guess)))
>   (define (sqrt-iter guess x)
>           (if (good-enough? guess x)
>               guess
>               (sqrt-iter (improve guess x) x)))
>   (sqrt-iter 1.0 x))
>```

这种嵌套定义被称为**块结构**
> 在上面的(sqrt x)过程中，x在sqrt中的定义中是受约束的，过程good-enough?、improve和sqrt-iter也都定义在sqrt中，因此没必要将x在这些过程中显式传递。可以将x作为内部定义的自由变量。
> 在外围的sqrt被调用时，x由实际参数得到自己的值，这种方式称为**词法作用域**
>
>```lisp
> (define (sqrt x)
>   (define (good-enough? guess)
>           (< (abs (- (square guess) x)) 0.001))
>   (define (improve guess)
>           (average guess (/ x guess)))
>   (define (sqrt-iter guess)
>           (if (good-enough? guess)
>               guess
>               (sqrt-iter (improve guess))))
>   (sqrt-iter 1.0))
>```
>> **x对于sqrt是约束变量，对于good-enough?、improve和sqrt-iter是自由变量。**
***

### 1.2过程与它们所产生的计算

> 一个过程也就是一种模式，它描述了一个计算**过程的局部演化方式**，描述了这一计算过程中的每个步骤是怎样基于前面的步骤建立起来的。

#### 1.2.1 线性的递归和迭代

> 阶乘：$n!=n*(n-1)*(n-2)*...3*2*1$
> 
> 计算过程1：
> $n!=n*((n-1)*(n-2)*...*3*2*1)=n*(n-1)!$
>>```lisp
>> (define (factorial n)
>>         (if (= n 1)
>>             1
>>             (* n factorial (- n 1))))
>>```
> 计算过程2：
> 将计算阶乘$n!$的规则描述为：先乘起1和2，而后将得到的结果乘以3，而后再乘以4，这样下去直到达到$n$。
>>```lisp
>> (define (factorial n)
>>         (fact-iter 1 1 n))
>> (define (fact-iter product counter max-count)
>>         (if(> counter max-count)
>>            product
>>            (fact-iter (* counter product)
>>                       (+ counter 1)
>>                       max-count)))
> 将计算$6!$的过程展开
> 过程1：
>>```
>> (factorial 6)
>> (* 6 (fractorial 5))
>> (* 6 (* 5 (fractorial 4)))
>> (* 6 (* 5 (* 4 (fractorial 3))))
>> (* 6 (* 5 (* 4 (* 3 (fractorial 2)))))
>> (* 6 (* 5 (* 4 (* 3 (* 2 (fratorial 1))))))
>> (* 6 (* 5 (* 4 (* 3 (* 2 1)))))
>> (* 6 (* 5 (* 4 (* 3 2))))
>> (* 6 (* 5 (* 4 6)))
>> (* 6 (* 5 24))
>> (* 6 120)
>> 720
> 过程2：
>>```
>> (fractorial 6)
>> (fact-iter 1 1 6)
>> (fact-iter 1 2 6)
>> (fact-iter 2 3 6)
>> (fact-iter 6 4 6)
>> (fact-iter 24 5 6)
>> (fact-iter 120 6 6)
>> (fact-iter 720 7 6)
>> 720
>
> 计算过程由一个推迟执行的运算链条刻画，称为一个**递归计算过程**。要执行这种计算过程，解释器就需要维护好那些以后要执行的操作的轨迹。
> **迭代计算过程**就是那种其状态可以用固定数目的*状态变量*描述的计算过程。于此同时，又存在着一套固定的规则，描述了计算过程在从一个状态到下一个状态转换时，这些*变量的更新方式*，还有一个（可能有的）*结束检测*，它描述这一计算过程应该终止的条件。

**递归计算过程**与**递归过程**不同，前者表示计算过程的进展方式，后者表示语法形式。

**尾递归**
在常量空间中执行迭代计算过程，即使计算过程是用递归过程描述的。
通过尾递归，可以使用常规过程调用机制描述迭代，不需要使用循环结构。

#### 1.2.2 树形递归

**(斐波那契数列)Fibonacci**
> $
Fib(n)=
\begin{cases}
0 &\text{n=0}\\
1 &\text{n=1}\\
Fib(n-1)+Fib(n-2)
\end{cases}
$
直接将公式翻译为Scheme代码:
>```lisp
> (define (fib n)
>         (cond ((= n 0) 0)
>               ((= n 1) 1)
>               (else (+ (fib (- n 1)
>                        (fib (- n 2)))))))
这种实现是典型的树形递归计算过程。该过程所需的计算步数随n的增加呈指数增长，空间需求呈线性增长。
> **一般说，树形递归计算过程里所需的步骤数将正比于树中的节点数，其空间需求正比于数的最大深度。**
![](img/fib树形递归计算过程.png)

**线性迭代方式实现：**

```lisp
(define (fib n)
        (fib-iter 1 0 n))
(define (fib-iter a b count)
        (if (= count 0)
            b)
            (fib-iter (+ a b) a (- count 1)))
```
> (fib 5)
> (fib-iter 1 0 5)
> (fib-iter 1 1 4)
> (fib-iter 2 1 3)
> (fib-iter 3 2 2)
> (fib-iter 5 3 1)
> (fib-iter 8 5 0)
> 5

> 用一对整数a和b，将它们分别初始化为fib(1)=1和fib(0)=0,而后反复的同时使用下面变换规则：
a<--a+b
b<--a
应用n次变换后，a，b分别等于fib(n+1)和fib(n)
>> 递归实现与迭代实现的区别：
>> 递归实现是一种自顶向下的计算过程，即:
>> fib(n)->fib(n-1)->fib(n-2)->...->fib(1)->fib(0)
>> 在过程展开至fib(1)和fib(0)之前,解释器无法获得fib(3)、fib(4)....fib(n-1)的值,要获得这些过程的值，解释器必须将这些过程展开至fib(1)和fib(0)，然后进行计算，由于每个分支上大于fib(1)的过程都需要展开计算，导致大量的冗余计算。
>> 迭代实现是自下而上的计算过程：
>> fib(0)->fib(1)->...->fib(n)
>> 较小的fib(n-1)总是先于fib(n)计算出来，避免了重复计算。每次fib(n-1)+fib(n-2)为一次迭代。可以使用一个状态变量counter维护迭代的次数，保证程序顺利终止。

#### 实例：换零钱方式的统计

> 有半美元（50美分）、四分之一美元(25美分)、10美分、5美分和1美分的硬币，给定任意数量的现金，计算所有换零钱方式的种数。
>> 分析：
>> 记硬币分别为c1,c2...cn，币值为d1,d2...dn
>> 将总数为a的现金换成n种硬币的不同方式的数目等于
>> - 不使用c1的兑换方式
>> *将现金数a换成除c1之外的所有其他硬币的不同方式数目*
>> $+$
>> - 使用c1的兑换方式
>> *将现金数a-d1(c1的币值)换成所有种类的硬币的不同方式数目*。
>>  `???`
>
>> 记将现金a兑换为n种硬币的方式数目为$f(a,(c1,c2...cn))$
>> $f(a,(c1,c2...cn))=f(a,(c2,c3...cn))+f((a-d1),(c1,c2...cn))$

```lisp
;;;硬币类型。输入硬币种类kinds-of-coins，输出硬币币值
(define (first-denomination kinds-of-coins)
        cond ((= kinds-of-coins 1) 1)
             ((= kinds-of-coins 2) 5)
             ((= kinds-of-coins 3) 10)
             ((= kinds-of-coins 4) 25)
             ((= kinds-of-coins 5) 50))

;;;将amount兑换为kinds=of-coins的方式数目。f(a,(c1,c2...cn))
;;;如果a=0，记为有1种兑换方式
;;;如果a<0，记为有0种兑换方式
;;;如果n=0，记为有0种兑换方式
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((< amount 0) 0)
        ((= kinds-of-coins 0) 0)
;;;f(a,(c2,c3...cn))
        (else (+ (cc amount
                     (- kinds-of-coins 1))
;;;f((a-d1),(c1,c2...cn))
                 (cc (- amount (first-denomination kinds-of-coins)
                     kinds-of-coins)))))

(define (count-change amount)
        (cc amount 5))
```

> (count-change 100)
> (cc 100 5)
> (+ (cc 100 4) (cc 50 5))
> (+ (+ (cc 100 3) (cc 75 4)) (+ (cc 50 4) (cc 25 5)))
> (+ (+ (+ (cc 100 2) (90 3)) (+ (cc 75 3) (cc 50 4)) (+ (+ (cc 50 3) (cc 25 4)) (+ (+ (cc 25 4) (cc -25 5))))))
> ...
>> 迭代实现：
>> ???

#### 1.2.3增长的阶

> 如果存在与$n$无关的整数$k_1$和$K_2$，使得：$K_1f(n)\leqslant R(n)\leqslant K_2f(n)$对任何足够大的$n$值都成立，我们称R(n)具有$\Theta(f(n))$的增长阶，记为$R(n)=\Theta(f(n))$

#### 1.2.4 求幂

> 线性递归过程，需要$\theta(n)$步和$\theta(n)$空间。

> $b^n=b*b^{n-1}$
> $b^0=1$

线性递归:

```lisp
(define (expt b n)
        (if (= n 0) 1
                (* b (expt b (- n 1)))))
```
=====>线性迭代
```lisp
(define (expt b n)
        (expt-iter b n 1))

(define (expt-iter b n e)
        (if (= n 0)
            e
            (expt-iter b 
                       (- n 1) 
                       (* b e))))
```
======>
> $\large b^n=(b^\frac n 2)^2 $ n是偶数
> $\large b^n=b*b^{n-1}$ n是奇数

```lisp
(define (fast-expt b n)
        (cond ((= n 0) 1)
              ((even? n) (square (fast-expt b (/ n 2))))
              (else (* b (fast-expt b (- n 1))))))

(define (even? n)
        (= (remainder n 2) 0))
```
=====>fast-expt迭代
???


#### 1.2.5 最大公约数

原理：欧几里得算法
> 如果r是a除以b的余数，那么a和b的公约数正好也是b和r的公约数
> $GCD(a,b)=GCD(b,r)$

```lisp
(define (gcd a b)
        (if (= b 0)
            a
            (gcd b (remainder a b))))
```

#### 1.2.6 实例：素数检测

寻找因子：
> 用从2开始的连续整数去检查它们能否整除n

```lisp
;;;最小质因数
(define (smallest-divisor n)
        (find-divisor n 2))
(define (find-divisor n test-divisor)
        (cond ((> (square test-divisor) n) n)
              ((divides? test-divisor n) test-divisor)
              (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b)
        (= (remainder b a) 0))
;;;检查是否素数
(define (prime? n)
        (= n (smallest-divisor n)))
```

费马检查：
>>费马小定理：
>> 如果n是一个素数，a是小于n的任意正整数，那么a的n次方与a模n同余。
>> $a^n\mod n=a$
> 
> 如果n不是素数，那么，大部分a<n都不满足上面的关系。**(翻译错误？)**

> 1. $base^{exp}\mod m$
```lisp
;;;1.计算一个数的幂对另一个数取模的结果
;;; base^exp mod m
(define (expmod base exp m)
        (cond ((= exp 0) 1)
              ((even? exp)
               (remainder (square (expmod base (/ exp 2 m)))))
              (else
               (remainder (* base (expmod base (-exp 1 m)) m)))))
;;;执行检查
;;;(random n)获取0--(n-1)之间的随机数
(define (fermat-test n)
        (define (try-ite a)
                (= (expmod a n n) a))
        (try-it (+1 (random (- n 1)))))
;;;运行指定次数的检查
(define (fast-prime? n times)
        (cond ((= times 0) true)
              ((fermat-test n) (fast-prime? n (- times 1)))
              (else false)))
```
概率算法：
> 不能保证计算结果的一定正确，只有概率上的正确性。
> 能够证明存在使出现错误的概率达到任意小的检查算法。