<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

* [网上的习题答案](#网上的习题答案)
* [自己做的](#自己做的)
	* [第一章  构造过程抽象](#第一章-构造过程抽象)
		* [1.1 程序设计的基本元素](#11-程序设计的基本元素)
			* [练习1.1](#练习11)
			* [练习1.2](#练习12)
			* [练习1.3](#练习13)
			* [练习1.4](#练习14)
			* [练习1.5](#练习15)
			* [练习1.6](#练习16)
			* [练习1.7](#练习17)
			* [练习1.8](#练习18)
			* [练习1.9](#练习19)
			* [练习1.10](#练习110)
			* [练习 1.11](#练习-111)
			* [练习1.12](#练习112)
			* [练习 1.13](#练习-113)
			* [练习 1.14](#练习-114)
			* [练习1.15](#练习115)

<!-- /code_chunk_output -->

# 网上的习题答案

> http://community.schemewiki.org/?sicp-solutions

# 自己做的

## 第一章  构造过程抽象

### 1.1 程序设计的基本元素

#### 练习1.1

下面是一系列表达式，对于每个表达式，解释器将输出什么结果？假定这一系列表达式是按照给出的顺序逐个求值的。

> `10` =>10
>
> `(+ 5 3 4)`=>`(+ 8 4)`=>12
>
> `(- 9 1)`=>8
>
> `(/ 6 2)`=>3
>
> `(+ (* 2 4) (- 4 6))`=>`(+ 8 -2)`=>6
>
> `(define a 3)`=>`a=3`
>
> `(define b (+ a 1))`=> `b=3+1=4`
>
> `(+ a b (* a b))`=>`(+ 3 4 (* 3 4))`=>`(+ 3 4 12)`=>19
>
> `(= a b)`=> #f
>
>``` lisp
> (if (and (> b a) (< b (* a b)))
>     b
>     a)
> => 
> (if (and (> 4 3) (< 4 (* 3 4)))
>     4
>     3)
> =>
> (if (and #t #t)) 4 3)
> => 4
>```
>``` lisp
> (cond ((= a 4) 6)
>       ((= b 4) (+ 6 7 a))
>       (else 25))
> =>
> (cond ((= 4 4) 6)
>       ((= 4 4) (+ 6 7 a))
>       (else 25))
> =>
> (cond (#f 6)
>       (#t (+ 6 7 3))
>       (else 25))
> => 16
>```
>``` lisp
> (+ 2 (if (> b a) b a))
> =>
> (+ 2 (if (> 4 3) b a))
> =>
> (+ 2 (if #t 4 3))
> =>
> (+ 2 4)
> =>6
>```
>``` lisp
> (* (cond ((> a b) a)
>          ((< a b) b)
>          (else -1))
>    (+ a 1))
> =>
> (* (cond ((> 3 4) a)
>          ((< 2 4) b)
>          (else -1))
>          (+ a 1))
> =>
> (* (cond (#f a)
>          (#t b)
>          (else -1))
>          (+ a 1))
> =>
> (* b (+ a 1))
> =>
>(* 4 (+ 3 1))
> =>16
>```

####练习1.2

请将下面表达式变换为前缀形式：

$$
\dfrac{5+4+(2-(3-(6+\dfrac{4} {5})))} {3(6-2)(2-7)} 
$$

>``` lisp
> (/ (+ 5 4
>         (- 2 (- 3 (+ 6 (/ 4 5)))))
>    (* 3 (- 6 2) (- 2 7)))
>```

#### 练习1.3

请定义一个过程，它以三个数为参数，返回其中较大的两个数之和。

>
>``` lisp
> (define (max-2-sum a b c)
>   (if(> a b)
>     (if(> b c)
>        (+ a b)
>        (+ a c))
>     (if(> a c)
>        (+ a b)
>        (+ b c))
> ))
>```

> - 判断a与b的大小
>   - 如果a>b,判断b与c的大小
>     - 如果b>c,即a>b>c,返回a+b
>     - 如果c>b,即a>b,c>b,返回a+c
>   - 如果b>a,判断a与c的大小
>     - 如果a>c,即b>a>c,返回a+b
>     - 如果c>a,即b>a,c>a,返回b+c

```flow
st=>start: Start
e=>end
cond=>condition: a>b?
cond_op_1=>condition: b>c?
cond_op_1_y=>operation: (+ a b)
cond_op_1_n=>operation: (+ a c)
cond_op_2=>condition: a>c?
cond_op_2_y=>operation: (+ b a)
cond_op_2_n=>operation: (+ b c)
st->cond
cond(yes)->cond_op_1
cond_op_1(yes)->cond_op_1_y->e
cond_op_1(no)->cond_op_1_n->e
cond(no)->cond_op_2
cond_op_2(yes)->cond_op_2_y->e
cond_op_2(no)->cond_op_2_n->e
```

#### 练习1.4

请仔细考察上面给出的允许运算符为复合表达式的组合式的求值模型，根据对这一模型的认识描述下面过程的行为。

``` lisp
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
```

> a+|b|

```flow
st=>start: Start
e=>end
op=>operation: if(> b 0)
cond=>condition: b>0? 
y=>operation: (+ a b)
n=>operation: (- a b)
st->op->cond
cond(yes)->y->e
cond(no)->n->e
```

#### 练习1.5

Ben Bitdiddle发明了一种检测方法，能够确定解释器究竟采用哪种序求值，是采用应用序还是采用正则序。他定义了下面两个过程：

```lisp
(define (p) (p))
(define (test x y)
  (if (= x 0)
      0
      y))
```

而后他求值下面的表达式：
`(test 0 (p))`
如果某个解释器采用的是应用序求值，Ben会看到什么样的情况？如果解释器采用正则序求值，他又会看到什么情况？请对你的回答做出解释。（无论采用正则序或者应用序，假定特殊形式if的求值规则总是一样的。其中的谓词部分先行求值，根据其结果确定随后求值的子表达式部分。）

> 应用序求值过程：`先求值参数而后应用`
> 对于过程`(test 0 (p))`,参数0已确定，参数(p)还未求值，因此首先求值(p),将应用`(define (p) (p))`,求值结果为(p),因此将继续求值(p),导致死循环。
> 正则序求值过程：`完全展开而后归约`
> 将过程`(test 0 (p))`展开,得到`(if (= 0 0) 0 (p))`,然后对if求值，根据if求值规则，谓词`(= 0 0)`首先求值，返回#t,因此得到if表达式的值为0。
>
> **应用序与正则序的区别**
> 由于应用序会求值每个参数，因此对于if表达式，两个分支都会进行求值，而正则序则只会对正确的分支求值，跳过不正确的分支。

#### 练习1.6

Alyssa P.Hacker看不出为什么需要将if提供为一种特殊形式，她问：“为什么我不能直接通过cond将它定义为一个常规过程呢?” Alyssa的朋友Eva Lu Ator断言确实可以这样做，并定义了if的一个新版本：

```lisp
(define (new-if predicate then-clause else-clause)
         (cond (predicate then-clause)
               (else else-clause)))
```

Eva给Alyssa演示她的程序：

```lisp
(new-if (= 2 3) 0 5)
5

(new-if (= 1 1) 0 5)
0
```

她很高兴地用自己的new-if重写了求平方根的程序：

```lisp
(define (sqrt-iter guess x)
        (new-if (good-enough? guess x)
                guess
                (sqrt-iter (improve guess x)
                           x)))
```

当Alyssa试着用这个过程去计算平方根时会发生什么事情呢？请给出解释。

> scheme解释器采用应用序求值，对于过程`(sqrt-iter guess x)`，当使用new-if时，解释器会对new-if的参数`guess`和`(sqrt-iter (improve guess x) x)`进行求值，即继续调用`(sqrt-iter)`自身,导致无法出发中断条件，程序死循环。
> 当使用if时，由于if是特殊形式，因此会先进行`(good-enough? guess x)`判断，再根据`good-enough?`的值决定求值哪个参数，因此当`good-enough?=>#t`时，程序返回`guess`。

> **对于递归过程，必须用if给出中断条件。**

#### 练习1.7

对于确定很小的数的平方根而言，在计算平方根中使用的检测good-enough?是很不好的。还有，在现实的计算机里，算术运算总是以一定的有限精度进行的。这也会使我们的检测不适合非常大的数的计算。请解释上述论断，用例子说明对很小和很大的数，这种检测都可能失败。实现good-enough?的另一种策略是监视猜测值在从一次迭代到下一次迭代的变换情况，当改变值相对于猜测值得比率很小时就结束。请设计一个采用这种终止测试方式的平方根过程。对于很大和很小的数，这一过程都能工作吗？

> 使用数值测试：
>> x=0.0000000001
>> (sqrt x)=>0.03125000106562499
>> x=99999999999999999999
>> (sqrt x)=>死循环
>
> 由于good-enough?中使用了常数0.001，因此，当x远远小于0.001时，计算会出现相当大的误差。
>>以测试数据0.0000000001为例，当guess=0.03时，(square guess)=>0.0009，$|0.0009-0.00001|=0.00089<0.001$,而实际上$\sqrt(0.0000000001)=0.00001$。
>
> 当x取很大的数时
>
> 通过打印`guess`和`(abs (- (square guess) x))`的值可以发现，当x取很大的数时，经过有限步数的迭代后，`guess`和`(abs (- (square guess) x))`保持不变，`(abs (- (square guess) x))`在一个很大的数量级，即`(< (abs (- (square guess) x)) 0.001))`的值始终为#t，也就是说，由于数字精度的问题，导致迭代无法继续。
>> 网上的解释
>>因为 mit-scheme 实现的小数精度不足以表示两个大数之间的差，所以 sqrt 会陷入死循环而无法得出正确结果。
>>
>
> 实现good-enough? 的新策略
>```lisp
> (define (new-good-enough? guess x)
>         (< (abs (- (/ (improve guess x) guess) 1))
>         0.0001))
>```
> $\left|\dfrac{\left(\dfrac{guess+\frac{x}{guess}}{2}\right)}{guess}-1\right|<0.0001$

#### 练习1.8

求立方根的牛顿法基于如下事实，如果y是x的立方根的一个近似值，那么下式将给出一个更好的近似值：
$\dfrac{x/y^2+2y}{3}$
请利用这一公式实现一个类似平方根过程的求立方根的过程。

>```lisp
> (define (improve guess x)
>         (/ (+ (/ x (square guess)) (* 2 guess)) 3))
>
> (define (square x)
>         (* x x))
>
> (define (good-enough? guess x)
>         (< (abs (- (/ (improve guess x) guess) 1))
>            0.0001))
>
> (define (cube-iter guess x)
>         (if (good-enough? guess x)
>             guess
>             (cube-iter (improve guess x)
>                        x)))
>
> (define (cube x)
>         (cube-iter 1.0 x))
>```

#### 练习1.9

下面几个过程各定义了一种加起两个正整数的方法，它们都基于过程inc(它将参数增加1)和dec(它将参数减少1).

```lisp
(define (+ a b)
        (if (= a 0)
            b
            (inc (+ (dec a ) b))))
```

```lisp
(define (+a b)
        (if (= a 0)
        b
        (+ (dec a) (inc b))))
```

请用代换模型展示这两个过程在求值(+ 4 5)时所产生的计算过程。这些计算过程是递归或者迭代的吗？
> 过程1：
>```
> (+ 4 5)
> (inc (+ (dec 4) 5))
> (inc (inc (+ (dec 3) 5)))
> (inc (inc (inc (+ (dec 2) 5))))
> (inc (inc (inc (inc (+ (dec 1) 5)))))
> (inc (inc (inc (inc (+ 0 5)))))
> (inc (inc (inc (inc 5))))
> (inc (inc (inc 6)))
> (inc (inc 7))
> (inc 8)
> 9
>```
>过程2：
> (+ 4 5)
> (+ (dec 4) (inc 5))
> (+ 3 6)
> (+ (dec 3) (inc 6))
> (+ 2 7)
> (+ (dec 2) (inc 7))
> (+ 1 8)
> (+ (dec 1) (inc 8))
> (+ 0 9)
> 9
>
>>过程1是递归的，过程2是迭代的。

#### 练习1.10

下面过程计算一个称为Ackermann函数的数学函数：

```lisp
(define (A x y)
        (cond ((= y 0) 0)
              ((= x 0) (* 2 y))
              ((= y 1) 2)
              (else (A (- x 1)
                       (A x (- y 1))))))
```
下面各表达式的值是什么：
```lisp
(A 1 10)
(A 2 4)
(A 3 3)
```
请考虑下面的过程，其中的A就是上面定义的过程：
```
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
```
请给出过程f、g和h对给定整数值n所计算的函数的数学定义。例如，(k n)计算的是$5n^2$

> (A 1 10)
>
> <s>
>
>>```lisp
>> (A 1 10)
>> (A 0 (A 1 9))
>> (* 2 (A 1 9))
>> (* 2 (A 0 (A 1 8)))
>> (* 2 (* 2 (A 1 8)))
>> (* 2 (* 2 (A 0 (A 1 7))))
>> (* 2 (* 2 (* 2 (A 1 7))))
>> (* 2 (* 2 (* 2 (A 0 (A 1 6)))))
>> (* 2 (* 2 (* 2 (* 2 (A 1 6)))))
>> (* 2 (* 2 (* 2 (* 2 (A 0 (A 1 5))))))
>> (* 2 (* 2 (* 2 (* 2 (* 2 (A 1 5))))))
>> (* 2 (* 2 (* 2 (* 2 (* 2 (A 0 (A 1 4)))))))
>> (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (A 1 4)))))))
>> (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (A 0 (A 1 3))))))))
>> (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (A 1 3))))))))
>> (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (A 0 (A 1 2)))))))))
>> (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (A 1 2)))))))))
>> (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (A 0 (A 1 1))))))))))
>> (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (A 1 1))))))))))
>> (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 2)))))))))
>> (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 4))))))))
>> (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 8)))))))
>> (* 2 (* 2 (* 2 (* 2 (* 2 (* 2 16))))))
>> (* 2 (* 2 (* 2 (* 2 (* 2 32)))))
>> (* 2 (* 2 (* 2 (* 2 64))))
>> (* 2 (* 2 (* 2 128)))
>> (* 2 (* 2 256))
>> (* 2 512)
>> 1024
>>```
> </s>
>
>>```
>> (A 1 10)
>> (A 0 (A 1 9))
>> (A 0 (A 0 (A 1 8)))
>> (A 0 (A 0 (A 0 (A 1 7))))
>> (A 0 (A 0 (A 0 (A 0 (A 1 6)))))
>> (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
>> (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
>> (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
>> (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
>> (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
>> (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
>> (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
>> (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
>> (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
>> (A 0 (A 0 (A 0 (A 0 (A 0 32)))))
>> (A 0 (A 0 (A 0 (A 0 64))))
>> (A 0 (A 0 (A 0 128)))
>> (A 0 (A 0 256))
>> (A 0 512)
>> (* 2 512)
>> 1024
>>```
>> $1024$
>
> (A 2 4)
>
>>```
>> (A 1 (A 2 3))
>> (A 1 (A 1 (A 2 2)))
>> (A 1 (A 1 (A 1 (A 2 1))))
>> (A 1 (A 1 (A 1 2)))
>> (A 1 (A 1 (A 0 (A 1 1))))
>> (A 1 (A 1 (A 0 2)))
>> (A 1 (A 1 4))
>> (A 1 (A 0 (A 1 3)))
>> (A 1 (A 0 (A 0 (A 1 2))))
>> (A 1 (A 0 (A 0 (A 0 (A 1 1)))))
>> (A 1 (A 0 (A 0 (A 0 2))))
>> (A 1 (A 0 (A 0 4)))
>> (A 1 (A 0 8))
>> (A 1 16)
>> ...
>>```
>> $2^{16}$
>
> (A 3 3)
>
>>```
>> (A 3 3)
>> (A 2 (A 3 2))
>> (A 2 (A 2 (A 3 1)))
>> (A 2 (A 2 2)
>> (A 2 (A 1 (A 2 1)))
>> (A 2 (A 1 2))
>> (A 2 (A 0 (A 1 1)))
>> (A 2 (A 0 2))
>> (A 2 4)
>> ...
>>```
>> $2^{16}$
>
> 过程A的函数表示
> $$
f(x,y)=
\begin{cases}
0&\text{if}&\text{ y = 0} \\
2y&\text{if}&\text{ x = 0}\\
2&\text{if}&\text{ y = 1}\\
f((x-1),f(x,(y-1)))
\end{cases}
$$
> (define (f n) (A 0 n))
>> (A 0 n)
>> (* 2 n)
>> $f(n)=2n$
>
> (define (g n) (A 1 n))
>> n=0
>> (A 1 0)
>> 0
>> n=1
>> (A 1 1)
>> 2=$2^1$
>> n>=2
>> (A 1 n)
>> (A 0 (A 1 (- n 1)))
>> (* 2 (A 1 (- n 1)))
>> $
g(n)=
\begin{cases}
0 &\text{n=0}\\
2(g(n-1))=>2^n &\text{n>=1}
\end{cases}
$
>
> (define (h n) (A 2 n))
>
>> n=0
>> (A 2 0)
>> => 0
>> n=1
>> (A 2 1)
>> =>2
>> n=2
>> (A 2 n)
>> (A 1 (A 2 (- n 1)))
>> h(n)=g(h(n-1))
>>
>> $
h(n)=
\begin{cases}
0 &\text{n=0}\\
2 &\text{n=1}\\
g(h(n-1))=2^{h(n-1)} &\text{n>=2}
\end{cases}
$
>>

#### 练习 1.11

> 函数$f$由如下的规则定义：如果$n<3$,那么$f(n)=n$;如果$n>3$,那么$f(n)=f(n+1)+2f(n-2)+3f(n-3)$。请写一个采用递归计算过程计算$f$的过程。再写一个采用迭代计算过程计算$f$的过程。

递归实现：

```lisp
(define (f n)
        (if (< n 3) n
            (+ (f (- n 1))
               (* 2 (f (- n 2)))
               (* 3 (f (- n 3))))))
```

迭代实现：
>思路，在过程中使用三个变量a,b,c分别保持f(n),f(n-1),和f(n-2)的状态
每次迭代
a<-a+2b+3c
b<-a
c<-b
同时使用变量counter记录迭代次数。

```lisp
(define (f-iter a b c n)
        (if (= n 2)
            a
            (f-iter (+ a (* 2 b) (* 3 c))
                    a
                    b 
                    (- n 1))))
(define (ff n)
        (if (< n 3) 
            n
            (f-iter 2 1 0 n)))
```

#### 练习1.12

> 下面的数值模式成为帕斯卡三角形(杨辉三角)：
> ```
>        1
>      1   1
>    1   2   1
>  1   3   3   1
>1   4   6   4   1
>       ...
>``` 
> 三角形边界上的数都是1，内部的每个数是位于它上面的两个数之和，请写一个过程，它采用递归计算过程计算出帕斯卡三角形。
>>打印数字 `(display 1)`

> 思路：
> 设行数为n，第n行有n个数。将第a行的第b个数记为x,即x=f(a,b)=f(a-1,b-1)+f(a-1,b)

```lisp
(define (get-num a b)
        (if (< a b) 0)
            (cond ((= a 1) 1)
                  ((= a b) 1)
                  (else (+ (get-num (- a 1) (- b 1))
                        (+ (get-num (- a 1) b))))))
```

#### 练习 1.13

> 证明Fib(n)是最接近$\phi^n/\sqrt{5}$的整数，其中$\phi=(1+\sqrt{5})/2$。提示，$\gamma=(1-\sqrt{5})/2,$利用归纳法和斐波那契数的定义，证明$Fib(n)=(\phi^n-\gamma^n)/\sqrt5$。

> $Fib(n)=(\phi^n-\gamma^n)/\sqrt5$
>>$ \begin{aligned}
&\phi=(1+\sqrt{5})/2 \implies \phi^2=(1+2\sqrt5+5)/4=(3+\sqrt5)/2=1+\phi \\  
&\gamma=(1-\sqrt{5})/2 \implies \gamma^2=(1-2\sqrt5+5)/4=(3-\sqrt5)/2=1+\gamma \\ 
&fib(0)=(\phi^0-\gamma^0)/\sqrt5=(1-1)/\sqrt5=0 \\
&fib(1)=(\phi^1-\gamma^1)/\sqrt5=(\dfrac{1+\sqrt5}{2}-\dfrac{1-\sqrt5}{2})/\sqrt5=1 \\
&\begin{aligned}fib(n-1)+fib(n-2)&=(\phi^{n-1}-\gamma^{n-1})/\sqrt5+(\phi^{n-2}-\gamma^{n-2})/\sqrt5 \\
&=(\phi^{(n-2)}(\phi+1)-\gamma^{n-2}(\gamma+1))/\sqrt5 \\
&=(\phi^{n-2}\phi^2-\gamma^{n-2}\gamma^2)/\sqrt5 \\
&=(\phi^n-\gamma^n)/\sqrt5=fib(n)
\end{aligned} \\
\end{aligned}$
>
> $|fib(n)-\phi^n/\sqrt5|<1/2$
>> $\begin{aligned}
&|fib(0)-\phi^0/\sqrt5|=|0-1/\sqrt5|=1/\sqrt5\lt1/\sqrt4\lt1/2 \\
&|fib(n)-\phi^n/\sqrt5|=|(\phi^n-\gamma^n)/\sqrt5-\phi^n/\sqrt5|=|\gamma^n/\sqrt5|\lt1/2 \\
&\begin{aligned}|fib(n+1)-\phi^{n+1}/\sqrt5|&=|(\phi^{n+1}-\gamma^{n+1})/\sqrt5-\phi^{n+1}/\sqrt5| \\
&=|\gamma^{n+1}/\sqrt5|=|\gamma^n/\sqrt5|*|\gamma| \\
&\lt1/2*|\gamma|=1/2*|(1-\sqrt5)/2| \\
&=1/2*(\sqrt5-1)/2<1/2*(\sqrt9-1)/2 \\
&=1/2
\end{aligned}
\end{aligned}$




#### 练习 1.14

> 请画出有关的树，展示1.2.2节的过程count-change在将11美分换成硬币时所产生的计算过程，相对于被换现金量的增加，这一计算过程的空间和步数增长的阶各是什么？

> ???

#### 练习1.15

> 在角(用弧度描述)$x$足够小时，其正弦值可以用$sinx\approx x$计算，而三角恒等式：$\sin x =3\sin {\dfrac x 3}-4(\sin {\dfrac x 3})^3$可以减小sin的参数大小(为完成这一练习，我们认为一个角是“足够小”，如果其数值不大于0.1弧度)。这些想法都体现在下述过程中：
```lisp
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
        (if (not (> (abs angel) 0.1))
            angle
            (p (sine (/ angle 3.0)))))
```
a)在求值(sine 12.15)时，p将被使用多少次?
b)在求值(sine a)时，由过程sine所产生的计算过程使用的空间和步数(作为a的函数)增长的阶石什么？
> a: 4次
12.15/3=4.05
4.05/3=1.35
1.35/3=0.45
0.45/3=0.15
0.15/3=0.05
> b:假设a>$0.1*3^n$
> (sine a)
> (p (sine (/ a 3.0)))
> (p (p (sine (/ (/ a 3.0) 3.0))))
> ...
> ```
> ???
> p本身的步数和空间均为常量，因此(sine a)空间增长的阶与p无关,记$a=b*3^n(b\lt0.1)$,即n每增加1，步数和空间均增加1，空间和步数增长的阶为$\theta(n)=\theta(\log_3a)$。


