# 第一章  构造过程抽象

## 1.1 程序设计的基本元素

### 练习1.1

> 下面是一系列表达式，对于每个表达式，解释器将输出什么结果？假定这一系列表达式是按照给出的顺序逐个求值的。

> `10` =>10
>
> `(+ 5 3 4)`=>`(+ 8 4)`=>12
>
> `(- 9 1)`=>8
>
> `(/ 6 2)`=>3
>
> `(+ (* 2 4) (- 4 6))`=>`(+ 8 -2)`=>6
>
> `(define a 3)`=>`a=3`
>
> `(define b (+ a 1))`=> `b=3+1=4`
>
> `(+ a b (* a b))`=>`(+ 3 4 (* 3 4))`=>`(+ 3 4 12)`=>19
>
> `(= a b)`=> #f
>
>``` lisp
> (if (and (> b a) (< b (* a b)))
>     b
>     a)
> => 
> (if (and (> 4 3) (< 4 (* 3 4)))
>     4
>     3)
> =>
> (if (and #t #t)) 4 3)
> => 4
>```
>``` lisp
> (cond ((= a 4) 6)
>       ((= b 4) (+ 6 7 a))
>       (else 25))
> =>
> (cond ((= 4 4) 6)
>       ((= 4 4) (+ 6 7 a))
>       (else 25))
> =>
> (cond (#f 6)
>       (#t (+ 6 7 3))
>       (else 25))
> => 16
>```
>``` lisp
> (+ 2 (if (> b a) b a))
> =>
> (+ 2 (if (> 4 3) b a))
> =>
> (+ 2 (if #t 4 3))
> =>
> (+ 2 4)
> =>6
>```
>``` lisp
> (* (cond ((> a b) a)
>          ((< a b) b)
>          (else -1))
>    (+ a 1))
> =>
> (* (cond ((> 3 4) a)
>          ((< 2 4) b)
>          (else -1))
>          (+ a 1))
> =>
> (* (cond (#f a)
>          (#t b)
>          (else -1))
>          (+ a 1))
> =>
> (* b (+ a 1))
> =>
>(* 4 (+ 3 1))
> =>16
>```

### 练习1.2

> 请将下面表达式变换为前缀形式：
>
> $$
\dfrac{5+4+(2-(3-(6+\dfrac{4} {5})))} {3(6-2)(2-7)} 
$$

>``` lisp
> (/ (+ 5 4
>         (- 2 (- 3 (+ 6 (/ 4 5)))))
>    (* 3 (- 6 2) (- 2 7)))
>```

### 练习1.3

> 请定义一个过程，它以三个数为参数，返回其中较大的两个数之和。

>
>``` lisp
> (define (max-2-sum a b c)
>   (if(> a b)
>     (if(> b c)
>        (+ a b)
>        (+ a c))
>     (if(> a c)
>        (+ a b)
>        (+ b c))
> ))
>```

> - 判断a与b的大小
>   - 如果a>b,判断b与c的大小
>     - 如果b>c,即a>b>c,返回a+b
>     - 如果c>b,即a>b,c>b,返回a+c
>   - 如果b>a,判断a与c的大小
>     - 如果a>c,即b>a>c,返回a+b
>     - 如果c>a,即b>a,c>a,返回b+c

```flow
st=>start: Start
e=>end
cond=>condition: a>b?
cond_op_1=>condition: b>c?
cond_op_1_y=>operation: (+ a b)
cond_op_1_n=>operation: (+ a c)
cond_op_2=>condition: a>c?
cond_op_2_y=>operation: (+ b a)
cond_op_2_n=>operation: (+ b c)
st->cond
cond(yes)->cond_op_1
cond_op_1(yes)->cond_op_1_y->e
cond_op_1(no)->cond_op_1_n->e
cond(no)->cond_op_2
cond_op_2(yes)->cond_op_2_y->e
cond_op_2(no)->cond_op_2_n->e
```

### 练习1.4

> 请仔细考察上面给出的允许运算符为复合表达式的组合式的求值模型，根据对这一模型的认识描述下面过程的行为。
>
>``` lisp
> (define (a-plus-abs-b a b)
>   ((if (> b 0) + -) a b))
>```

> a+|b|

```flow
st=>start: Start
e=>end
op=>operation: if(> b 0)
cond=>condition: b>0? 
y=>operation: (+ a b)
n=>operation: (- a b)
st->op->cond
cond(yes)->y->e
cond(no)->n->e
```

### 练习1.5

> Ben Bitdiddle发明了一种检测方法，能够确定解释器究竟采用哪种序求值，是采用应用序还是采用正则序。他定义了下面两个过程：
> ```lisp
> (define (p) (p))
> (define (test x y)
>   (if (= x 0)
>       0
>       y))
>```
> 而后他求值下面的表达式：
> `(test 0 (p))`
> 如果某个解释器采用的是应用序求值，Ben会看到什么样的情况？如果解释器采用正则序求值，他又会看到什么情况？请对你的回答做出解释。（无论采用正则序或者应用序，假定特殊形式if的求值规则总是一样的。其中的谓词部分先行求值，根据其结果确定随后求值的子表达式部分。）

> 应用序求值过程：`先求值参数而后应用`
> 对于过程`(test 0 (p))`,参数0已确定，参数(p)还未求值，因此首先求值(p),将应用`(define (p) (p))`,求值结果为(p),因此将继续求值(p),导致死循环。
> 正则序求值过程：`完全展开而后归约`
> 将过程`(test 0 (p))`展开,得到`(if (= 0 0) 0 (p))`,然后对if求值，根据if求值规则，谓词`(= 0 0)`首先求值，返回#t,因此得到if表达式的值为0。
>
> **应用序与正则序的区别**
> 由于应用序会求值每个参数，因此对于if表达式，两个分支都会进行求值，而正则序则只会对正确的分支求值，跳过不正确的分支。

### 练习1.6

> Alyssa P.Hacker看不出为什么需要将if提供为一种特殊形式，她问：“为什么我不能直接通过cond将它定义为一个常规过程呢?” Alyssa的朋友Eva Lu Ator断言确实可以这样做，并定义了if的一个新版本：
>```lisp
> (define (new-if predicate then-clause else-clause)
>         (cond (predicate then-clause)
>               (else else-clause)))
>```
> Eva给Alyssa演示她的程序：
>```lisp
> (new-if (= 2 3) 0 5)
> 5
>
> (new-if (= 1 1) 0 5)
> 0
>```
> 她很高兴地用自己的new-if重写了求平方根的程序：
>```lisp
> (define (sqrt-iter guess x)
>         (new-if (good-enough? guess x)
>                 guess
>                 (sqrt-iter (improve guess x)
>                            x)))
>```
> 当Alyssa试着用这个过程去计算平方根时会发生什么事情呢？请给出解释。

> scheme解释器采用应用序求值，对于过程`(sqrt-iter guess x)`，当使用new-if时，解释器会对new-if的参数`guess`和`(sqrt-iter (improve guess x) x)`进行求值，即继续调用`(sqrt-iter)`自身,导致无法出发中断条件，程序死循环。
> 当使用if时，由于if是特殊形式，因此会先进行`(good-enough? guess x)`判断，再根据`good-enough?`的值决定求值哪个参数，因此当`good-enough?=>#t`时，程序返回`guess`。

> **对于递归过程，必须用if给出中断条件。**

### 练习1.7

> 对于确定很小的数的平方根而言，在计算平方根中使用的检测good-enough?是很不好的。还有，在现实的计算机里，算术运算总是以一定的有限精度进行的。这也会使我们的检测不适合非常大的数的计算。请解释上述论断，用例子说明对很小和很大的数，这种检测都可能失败。实现good-enough?的另一种策略是监视猜测值在从一次迭代到下一次迭代的变换情况，当改变值相对于猜测值得比率很小时就结束。请设计一个采用这种终止测试方式的平方根过程。对于很大和很小的数，这一过程都能工作吗？

> 使用数值测试：
>> x=0.0000000001
>> (sqrt x)=>0.03125000106562499
>> x=99999999999999999999
>> (sqrt x)=>死循环
>
> 由于good-enough?中使用了常数0.001，因此，当x远远小于0.001时，计算会出现相当大的误差。
>>以测试数据0.0000000001为例，当guess=0.03时，(square guess)=>0.0009，$|0.0009-0.00001|=0.00089<0.001$,而实际上$\sqrt(0.0000000001)=0.00001$。
>
> 当x取很大的数时
>
> 通过打印`guess`和`(abs (- (square guess) x))`的值可以发现，当x取很大的数时，经过有限步数的迭代后，`guess`和`(abs (- (square guess) x))`保持不变，`(abs (- (square guess) x))`在一个很大的数量级，即`(< (abs (- (square guess) x)) 0.001))`的值始终为#t，也就是说，由于数字精度的问题，导致迭代无法继续。
>> 网上的解释
>>因为 mit-scheme 实现的小数精度不足以表示两个大数之间的差，所以 sqrt 会陷入死循环而无法得出正确结果。
>>
>
> 实现good-enough? 的新策略
>```lisp
> (define (new-good-enough? guess x)
>         (< (abs (- (/ (improve guess x) guess) 1))
>         0.0001))
>```
> $\left|\dfrac{\left(\dfrac{guess+\frac{x}{guess}}{2}\right)}{guess}-1\right|<0.0001$

### 练习1.8

> 求立方根的牛顿法基于如下事实，如果y是x的立方根的一个近似值，那么下式将给出一个更好的近似值：
$\dfrac{x/y^2+2y}{3}$
> 请利用这一公式实现一个类似平方根过程的求立方根的过程。

>```lisp
> (define (improve guess x)
>         (/ (+ (/ x (square guess)) (* 2 guess)) 3))
>
> (define (square x)
>         (* x x))
>
> (define (good-enough? guess x)
>         (< (abs (- (/ (improve guess x) guess) 1))
>            0.0001))
>
> (define (cube-iter guess x)
>         (if (good-enough? guess x)
>             guess
>             (cube-iter (improve guess x)
>                        x)))
>
> (define (cube x)
>         (cube-iter 1.0 x))
>```